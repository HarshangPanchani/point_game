<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>POINT - Card Game</title>
    
    <!-- FIREBASE COMPAT SDKs (Stable, Global Scope) -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-analytics-compat.js"></script>

    <style>
        :root {
            --bg-color: #2E7D32;
            --card-width: 60px;
            --card-height: 84px;
            --text-color: white;
            --accent: #FFD700;
            --danger: #ff4444;
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }
        body {
            margin: 0; padding: 0;
            font-family: 'Segoe UI', Tahoma, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow: hidden;
            height: 100vh; width: 100vw;
        }

        /* Landscape Warning */
        #portrait-warning {
            display: none;
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #1a1a1a; z-index: 9999;
            flex-direction: column; justify-content: center; align-items: center;
            text-align: center; padding: 20px;
        }
        @media (orientation: portrait) { #portrait-warning { display: flex; } }

        /* Screens */
        .screen {
            display: none; flex-direction: column; align-items: center; justify-content: center;
            width: 100%; height: 100%; position: absolute; top: 0; left: 0;
            overflow-y: auto;
        }
        .active-screen { display: flex; }

        /* UI Elements */
        input, button { padding: 10px 15px; margin: 10px; border-radius: 5px; border: none; font-size: 16px; }
        button { cursor: pointer; background: var(--accent); color: #000; font-weight: bold; box-shadow: 0 4px 0 #b39700; transition: transform 0.1s; }
        button:active { transform: translateY(4px); box-shadow: none; }
        button:disabled { background: #ccc; cursor: not-allowed; box-shadow: none; transform: none; }
        button.danger { background: var(--danger); color: white; box-shadow: 0 4px 0 #cc0000; }
        input { color: #000; text-align: center; }

        /* Game Layout */
        #game-ui { width: 100%; height: 100%; display: grid; grid-template-rows: 40px 1fr 140px; }
        #top-bar { background: rgba(0,0,0,0.5); display: flex; justify-content: space-between; align-items: center; padding: 0 20px; font-size: 14px; }
        
        #table-area { display: flex; justify-content: center; align-items: center; position: relative; }
        #opponents { position: absolute; top: 10px; width: 100%; display: flex; justify-content: center; gap: 20px; }
        
        .opponent {
            background: rgba(0,0,0,0.4); padding: 5px 10px; border-radius: 10px;
            text-align: center; font-size: 12px; opacity: 0.8;
            border: 2px solid transparent; transition: all 0.3s;
        }
        .opponent.active-turn { border: 2px solid var(--accent); background: rgba(0,0,0,0.8); transform: scale(1.1); }

        .deck-placeholder {
            width: var(--card-width); height: var(--card-height);
            border: 2px dashed rgba(255,255,255,0.5); border-radius: 5px; margin: 0 20px;
            display: flex; justify-content: center; align-items: center; position: relative;
            background: rgba(0,0,0,0.1);
        }

        #player-area { background: rgba(0,0,0,0.8); display: flex; flex-direction: column; align-items: center; padding-bottom: 5px; }
        #hand-container { display: flex; justify-content: center; margin-top: -30px; height: 90px; width: 100%; overflow-x: auto; }
        #controls { display: flex; gap: 10px; margin-top: 5px; }

        /* Cards */
        .card {
            width: var(--card-width); height: var(--card-height); background: white; color: black;
            border-radius: 5px; display: flex; flex-direction: column; justify-content: space-between;
            padding: 2px 5px; box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
            font-weight: bold; font-family: monospace; cursor: pointer; position: relative; margin: 0 2px;
            flex-shrink: 0; transition: transform 0.2s;
        }
        .card.selected { transform: translateY(-20px); border: 3px solid var(--accent); z-index: 10; }
        .card.red { color: #d40000; }
        .card-back { background: repeating-linear-gradient(45deg, #606dbc, #606dbc 10px, #465298 10px, #465298 20px); color: transparent; }
        .card-center { font-size: 24px; align-self: center; position: absolute; top: 50%; transform: translate(0, -50%); }
        .card-corner { font-size: 12px; line-height: 1; }
        .card-corner.bottom { transform: rotate(180deg); align-self: flex-end; }

        /* Scoreboard */
        table { width: 90%; border-collapse: collapse; margin-top: 20px; background: white; color: black; font-size: 14px; }
        th, td { border: 1px solid #ccc; padding: 8px; text-align: center; }
        th { background: #eee; }
        tr.total-row { background: var(--accent); font-weight: bold; }
        .winner-hl { color: green; font-weight: bold; }
        .loser-hl { color: red; font-weight: bold; }

        #toast {
            position: fixed; bottom: 50%; left: 50%; transform: translate(-50%, 50%);
            background: rgba(0,0,0,0.9); color: white; padding: 15px 30px;
            border-radius: 30px; opacity: 0; pointer-events: none; transition: opacity 0.3s;
            text-align: center; z-index: 10000;
        }
        
        .copy-btn { background: transparent; border: 1px solid var(--accent); color: var(--accent); padding: 5px; font-size: 12px; margin-left: 10px; box-shadow: none; }
        
        .kick-btn {
            background: #ff4444; color: white; border: none; font-size: 10px; 
            padding: 2px 5px; margin-left: 10px; border-radius: 3px; cursor: pointer;
        }
    </style>
</head>
<body>

    <div id="portrait-warning"><h1>Rotate Device</h1></div>

    <!-- Start Screen -->
    <div id="start-screen" class="screen active-screen">
        <h1 style="color:var(--accent); font-size: 40px; margin-bottom:5px;">POINT</h1>
        <p style="color:#ccc;">Free Multiplayer</p>
        <input type="text" id="username" placeholder="Your Name" maxlength="10">
        <div>
            <button onclick="createLobby()">Create Game</button>
            <button onclick="toggleJoin()">Join Game</button>
        </div>
        <div id="join-inputs" style="display:none; text-align:center;">
            <input type="text" id="room-code" placeholder="Paste Code/Link" style="width:150px;">
            <br><button onclick="joinLobby()">Connect</button>
        </div>
        <p id="status-msg" style="color:#aaa; font-size:12px;">Initializing...</p>
    </div>

    <!-- Lobby -->
    <div id="lobby-screen" class="screen">
        <h2 style="margin-top:20px;">Lobby</h2>
        <div style="background:rgba(255,255,255,0.1); padding:10px; border-radius:10px; text-align:center;">
            <span style="font-size:12px; color:#ccc;">ROOM CODE:</span><br>
            <strong id="lobby-code-display" style="font-size:24px; color:var(--accent); letter-spacing:2px;">...</strong>
            <button onclick="copyLink()" class="copy-btn">COPY LINK</button>
        </div>
        
        <div id="host-panel" style="display:none; margin-top:10px;">
            <label>Late Penalty: </label>
            <input type="number" id="late-penalty" value="10" style="width:50px;">
            <br>
            <button onclick="startGame()">START GAME</button>
        </div>

        <ul id="player-list" style="list-style:none; padding:0; width:300px; margin-top:20px;"></ul>
        <p id="lobby-wait">Waiting for host...</p>
    </div>

    <!-- Game -->
    <div id="game-screen" class="screen">
        <div id="game-ui">
            <div id="top-bar">
                <span>Room: <span id="game-room-id"></span></span>
                <span id="round-ind">R: 1</span>
                <span id="turn-ind">Waiting...</span>
            </div>
            <div id="table-area">
                <div id="opponents"></div>
                <div class="deck-placeholder" id="draw-pile" onclick="performAction('PICK', 'DECK')">
                    <div class="card card-back" style="position:absolute;"></div>
                    <span style="z-index:2; background:rgba(0,0,0,0.6);">DECK</span>
                </div>
                <div class="deck-placeholder" id="discard-pile" onclick="performAction('PICK', 'TRAY')">
                    <span>TRAY</span>
                </div>
            </div>
            <div id="player-area">
                <div id="hand-sum" style="font-size:12px; color:#aaa;">Sum: 0</div>
                <div id="hand-container"></div>
                <div id="controls">
                    <button id="btn-show" onclick="performAction('SHOW')" class="danger" disabled>SHOW</button>
                    <button id="btn-discard" onclick="performAction('DISCARD')" disabled>DISCARD</button>
                    <div id="pick-hint" style="display:none; color:var(--accent); font-weight:bold; align-self:center;">Pick Card</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Scoreboard -->
    <div id="score-screen" class="screen">
        <h2>Scoreboard</h2>
        <div style="overflow-y:auto; max-height:60%; width:100%; display:flex; justify-content:center;">
            <table id="score-table"></table>
        </div>
        <div style="margin-top:20px;">
            <button id="next-round-btn" onclick="nextRound()" style="display:none;">Next Round</button>
            <button onclick="exitGame()" style="background:#555">Exit</button>
        </div>
    </div>

    <div id="toast">Message</div>

    <script>
        // --- 1. CONFIGURATION ---
        const firebaseConfig = {
            apiKey: "AIzaSyAZ7-gmZfu6nfRvY-4hqdqQ86lGE405RQU",
            authDomain: "pointgame-281d5.firebaseapp.com",
            // Using the standard RTDB URL format for US Central
            databaseURL: "https://pointgame-281d5-default-rtdb.firebaseio.com",
            projectId: "pointgame-281d5",
            storageBucket: "pointgame-281d5.firebasestorage.app",
            messagingSenderId: "1006005693168",
            appId: "1:1006005693168:web:e26847ed3f4371146bf035",
            measurementId: "G-SS7KEGN87R"
        };

        // --- 2. INITIALIZATION ---
        // Using Global 'firebase' namespace from Compat scripts
        try {
            firebase.initializeApp(firebaseConfig);
            firebase.analytics();
            window.db = firebase.database();
            document.getElementById('status-msg').innerText = "Server Ready";
            console.log("Firebase Initialized Successfully");
        } catch (e) {
            console.error(e);
            alert("Firebase Error: " + e.message);
        }

        // --- 3. GAME STATE ---
        let myId = localStorage.getItem('point_uid') || Math.random().toString(36).substr(2, 9);
        localStorage.setItem('point_uid', myId);
        let myName = localStorage.getItem('point_name') || "";
        let roomId = null;
        let isHost = false;
        let gameData = null;
        let selectedCardIndices = [];

        // Auto-fill Logic
        const params = new URLSearchParams(window.location.search);
        if(params.get('room')) {
            document.getElementById('room-code').value = params.get('room');
            document.getElementById('join-inputs').style.display = 'block';
        }
        if(myName) document.getElementById('username').value = myName;

        // --- 4. FUNCTIONS ---

        function toggleJoin() { document.getElementById('join-inputs').style.display = 'block'; }

        function createLobby() {
            myName = document.getElementById('username').value.trim();
            if(!myName) return showToast("Enter Name");
            localStorage.setItem('point_name', myName);
            
            roomId = Math.random().toString(36).substr(2, 6).toUpperCase();
            isHost = true;
            
            const initialData = {
                host: myId,
                penalty: 10,
                status: 'LOBBY',
                round: 1,
                turnIndex: 0,
                turnPhase: 'DISCARD',
                deck: [],
                tray: [],
                players: {
                    [myId]: { name: myName, score: 0, history: [], hand: [] }
                }
            };
            
            // Set data with Error Handling
            window.db.ref(`rooms/${roomId}`).set(initialData)
                .then(() => enterLobby())
                .catch(err => {
                    alert("ERROR Creating Lobby: " + err.message + "\nCheck your Security Rules.");
                });
        }

        window.joinLobby = function() {
            myName = document.getElementById('username').value.trim();
            let code = document.getElementById('room-code').value.trim().toUpperCase();
            
            // FIXED: Extract room code from URL
            if(code.includes('?room=')) code = code.split('?room=')[1].split('&')[0];
            if(code.includes('/')) code = code.split('/').pop();
            
            if(!myName || !code) return showToast("Enter Name & Code");
            localStorage.setItem('point_name', myName);
            
            roomId = code;
            const roomRef = ref(db, `rooms/${roomId}`);
            
            get(roomRef).then(snap => {
                if(!snap.exists()) return showToast("Room not found!");
                
                const roomData = snap.val();
                const updates = {};
                
                // FIXED: Late joiner penalty logic
                if(roomData.status === 'GAME' && roomData.round > 1) {
                    const penalty = roomData.penalty || 10;
                    const missedRounds = roomData.round - 1;
                    const penaltyHistory = Array(missedRounds).fill(penalty);
                    const totalPenalty = penalty * missedRounds;
                    
                    updates[`rooms/${roomId}/players/${myId}`] = {
                        name: myName,
                        score: totalPenalty,
                        history: penaltyHistory,
                        hand: []
                    };
                } else {
                    updates[`rooms/${roomId}/players/${myId}`] = {
                        name: myName,
                        score: 0,
                        history: [],
                        hand: []
                    };
                }
                
                update(ref(db), updates).then(() => enterLobby());
            }).catch(err => showToast("Connection error: " + err.message));
        }                   

        function enterLobby() {
            showScreen('lobby-screen');
            document.getElementById('lobby-code-display').innerText = roomId;
            
            // ADDED: Setup disconnect handler
            const playerRef = ref(db, `rooms/${roomId}/players/${myId}`);
            onDisconnect(playerRef).remove();
            
            onValue(ref(db, `rooms/${roomId}`), (snapshot) => {
                gameData = snapshot.val();
                
                if(!gameData) {
                    alert("Room has been closed");
                    window.location.reload();
                    return;
                }
                
                // FIXED: Check if kicked
                if(gameData.players && !gameData.players[myId]) {
                    alert("You have been removed from the game");
                    window.location.reload();
                    return;
                }

                // Update UI based on game status
                if(gameData.status === 'LOBBY') {
                    renderLobby();
                } else if(gameData.status === 'GAME') {
                    if(!document.getElementById('game-screen').classList.contains('active-screen')) {
                        showScreen('game-screen');
                    }
                    renderGame();
                } else if(gameData.status === 'SCORE') {
                    if(!document.getElementById('score-screen').classList.contains('active-screen')) {
                        showScreen('score-screen');
                    }
                    renderScoreboard();
                }
            });
        }

        function renderLobby() {
            const list = document.getElementById('player-list');
            list.innerHTML = '';
            const players = Object.keys(gameData.players || {});
            
            players.forEach(pid => {
                const p = gameData.players[pid];
                let kickHtml = '';
                if(gameData.host === myId && pid !== myId) {
                    kickHtml = `<button class="kick-btn" onclick="kickPlayer('${pid}')">KICK</button>`;
                }
                list.innerHTML += `<li style="padding:5px; border-bottom:1px solid #444; display:flex; justify-content:space-between;">
                    <span>${p.name}</span>
                    ${kickHtml}
                </li>`;
            });
            
            if(gameData.host === myId) {
                document.getElementById('host-panel').style.display = 'block';
                document.getElementById('lobby-wait').style.display = 'none';
            } else {
                document.getElementById('host-panel').style.display = 'none';
                document.getElementById('lobby-wait').style.display = 'block';
            }
        }

        function kickPlayer(playerId) {
            if(!confirm("Kick this player?")) return;
            window.db.ref(`rooms/${roomId}/players/${playerId}`).remove();
        }

        function startGame() {
            const penalty = parseInt(document.getElementById('late-penalty').value) || 10;
            const updates = {
                [`rooms/${roomId}/penalty`]: penalty,
                [`rooms/${roomId}/status`]: 'GAME',
                [`rooms/${roomId}/round`]: 1
            };
            window.db.ref().update(updates).then(() => startRoundDB());
        }

        function startRoundDB() {
            let deck = createDeck();
            let tray = [deck.shift()];
            
            const playerIds = Object.keys(gameData.players);
            const updates = {};
            
            // Initialize hands for all players
            playerIds.forEach(pid => {
                updates[`rooms/${roomId}/players/${pid}/hand`] = deck.splice(0, 7);
            });
            
            updates[`rooms/${roomId}/deck`] = deck;
            updates[`rooms/${roomId}/tray`] = tray;
            
            // FIXED: Rotate starter based on round
            const starterIndex = (gameData.round - 1) % playerIds.length;
            updates[`rooms/${roomId}/turnIndex`] = starterIndex;
            updates[`rooms/${roomId}/turnPhase`] = 'DISCARD';
            updates[`rooms/${roomId}/status`] = 'GAME';
            
            // ADDED: Clear last round data
            updates[`rooms/${roomId}/lastRoundData`] = null;
            
            update(ref(db), updates).then(() => {
                showScreen('game-screen');
                selectedCardIndices = []; // Reset selection
            });
        }

        window.performAction = function(type, payload) {
            if(!gameData || gameData.status !== 'GAME') return;
            if(!isMyTurn()) return showToast("Not your turn!");
            
            const updates = {};
            const playerRef = `rooms/${roomId}/players/${myId}`;
            const roomRef = `rooms/${roomId}`;
            
            if(type === 'DISCARD') {
                if(gameData.turnPhase !== 'DISCARD') return showToast("Must discard first!");
                
                const myHand = gameData.players[myId].hand || [];
                if(selectedCardIndices.length === 0) return showToast("Select cards to discard");
                
                // FIXED: Validate same value
                const selectedCards = selectedCardIndices.map(i => myHand[i]);
                const firstVal = selectedCards[0].val;
                if(!selectedCards.every(c => c.val === firstVal)) {
                    return showToast("Cards must have same value!");
                }
                
                const newHand = myHand.filter((_, i) => !selectedCardIndices.includes(i));
                const newTray = [...(gameData.tray || []), ...selectedCards];
                
                updates[`${playerRef}/hand`] = newHand;
                updates[`${roomRef}/tray`] = newTray;
                updates[`${roomRef}/turnPhase`] = 'PICK';
                
                selectedCardIndices = [];
                
            } else if (type === 'PICK') {
                if(gameData.turnPhase !== 'PICK') return showToast("Discard first!");
                
                let newCard = null;
                let newDeck = [...(gameData.deck || [])];
                let newTray = [...(gameData.tray || [])];
                
                if(payload === 'DECK') {
                    // FIXED: Reshuffle logic
                    if(newDeck.length === 0) {
                        if(newTray.length > 1) {
                            const top = newTray.pop();
                            const reshuffleCards = [...newTray];
                            newDeck = shuffle(reshuffleCards);
                            newTray = [top];
                        } else {
                            return showToast("No cards left!");
                        }
                    }
                    newCard = newDeck.shift();
                } else if (payload === 'TRAY') {
                    if(newTray.length === 0) return showToast("Tray is empty!");
                    newCard = newTray.pop();
                }
                
                if(!newCard) return;
                
                const myHand = gameData.players[myId].hand || [];
                updates[`${playerRef}/hand`] = [...myHand, newCard];
                updates[`${roomRef}/deck`] = newDeck;
                updates[`${roomRef}/tray`] = newTray;
                
                // FIXED: Next turn logic
                const pIds = Object.keys(gameData.players);
                let nextIdx = (gameData.turnIndex + 1) % pIds.length;
                updates[`${roomRef}/turnIndex`] = nextIdx;
                updates[`${roomRef}/turnPhase`] = 'DISCARD';
            } 
            else if (type === 'SHOW') {
                if(gameData.turnPhase !== 'DISCARD') return showToast("Can only SHOW at start of turn!");
                handleShowLogic();
                return;
            }
            
            update(ref(db), updates).catch(err => showToast("Error: " + err.message));
        }       

        function handleShowLogic() {
            const myHand = gameData.players[myId].hand || [];
            const mySum = calculateHandSum(myHand);
            
            if(mySum > 5) return showToast("Sum must be â‰¤ 5 to SHOW!");
            
            const pIds = Object.keys(gameData.players);
            let results = pIds.map(pid => ({
                id: pid,
                name: gameData.players[pid].name,
                sum: calculateHandSum(gameData.players[pid].hand || [])
            }));
            
            let lowest = Math.min(...results.map(r => r.sum));
            let updates = {};
            let winnerIds = [];
            let loserId = null;
            
            // FIXED: Proper win/loss logic
            if(mySum === lowest) {
                // Correct SHOW - Winners get 0, others get their sum
                results.forEach(r => {
                    if(r.sum === lowest) {
                        addScoreToHistory(updates, r.id, 0);
                        winnerIds.push(r.id);
                    } else {
                        addScoreToHistory(updates, r.id, r.sum);
                    }
                });
            } else {
                // WRONG SHOW - Penalty calculation
                loserId = myId;
                
                // Count players with sum less than or equal to caller's sum (excluding caller)
                let betterPlayers = results.filter(r => r.sum <= mySum && r.id !== myId).length;
                let myPenalty = 30 * betterPlayers;
                
                results.forEach(r => {
                    if(r.id === myId) {
                        addScoreToHistory(updates, r.id, myPenalty);
                    } else if (r.sum === lowest) {
                        addScoreToHistory(updates, r.id, 0);
                        winnerIds.push(r.id);
                    } else {
                        addScoreToHistory(updates, r.id, r.sum);
                    }
                });
            }
            
            updates[`rooms/${roomId}/status`] = 'SCORE';
            updates[`rooms/${roomId}/lastRoundData`] = { 
                winners: winnerIds, 
                loser: loserId,
                round: gameData.round 
            };
            
            update(ref(db), updates).catch(err => showToast("Error: " + err.message));
        }

        function addScoreToHistory(updates, pid, score) {
            const history = gameData.players[pid].history || [];
            const total = (gameData.players[pid].score || 0) + score;
            updates[`rooms/${roomId}/players/${pid}/history`] = [...history, score];
            updates[`rooms/${roomId}/players/${pid}/score`] = total;
        }

        function nextRound() {
            const updates = {
                [`rooms/${roomId}/round`]: gameData.round + 1
            };
            window.db.ref().update(updates).then(() => startRoundDB());
        }

        function renderGame() {
            if(!gameData || !gameData.players || !gameData.players[myId]) return;
            
            const pIds = Object.keys(gameData.players);
            const currentPlayerId = pIds[gameData.turnIndex];
            const isMyTurnNow = (currentPlayerId === myId);
            
            document.getElementById('game-room-id').innerText = roomId;
            document.getElementById('round-ind').innerText = "Round: " + gameData.round;
            
            // FIXED: Better turn indicator
            const turnInd = document.getElementById('turn-ind');
            if(isMyTurnNow) {
                turnInd.innerText = `YOUR TURN - ${gameData.turnPhase}`;
                turnInd.style.color = "var(--accent)";
                turnInd.style.fontWeight = "bold";
            } else {
                turnInd.innerText = `${gameData.players[currentPlayerId].name}'s Turn`;
                turnInd.style.color = "white";
                turnInd.style.fontWeight = "normal";
            }

            // Render opponents
            const oppDiv = document.getElementById('opponents');
            oppDiv.innerHTML = '';
            pIds.forEach(pid => {
                if(pid !== myId) {
                    const p = gameData.players[pid];
                    const isActive = (pid === currentPlayerId);
                    oppDiv.innerHTML += `
                        <div class="opponent ${isActive ? 'active-turn' : ''}">
                            <div style="font-weight:bold;">${p.name}</div>
                            <div style="font-size:18px; margin-top:3px;">ðŸ‚  ${p.hand ? p.hand.length : 0}</div>
                        </div>`;
                }
            });
            
            // FIXED: Tray rendering with proper styling
            const trayEl = document.getElementById('discard-pile');
            if(gameData.tray && gameData.tray.length > 0) {
                const top = gameData.tray[gameData.tray.length-1];
                trayEl.innerHTML = renderCardHTML(top);
                trayEl.style.borderColor = (isMyTurnNow && gameData.turnPhase === 'PICK') ? 
                    'var(--accent)' : 'rgba(255,255,255,0.5)';
                trayEl.style.cursor = (isMyTurnNow && gameData.turnPhase === 'PICK') ? 'pointer' : 'default';
            } else {
                trayEl.innerHTML = `<span style="font-size:10px; color:#aaa;">TRAY<br>(Empty)</span>`;
                trayEl.style.borderColor = 'rgba(255,255,255,0.3)';
                trayEl.style.cursor = 'default';
            }
            
            // FIXED: Deck styling
            const deckEl = document.getElementById('draw-pile');
            deckEl.style.borderColor = (isMyTurnNow && gameData.turnPhase === 'PICK') ? 
                'var(--accent)' : 'rgba(255,255,255,0.5)';
            deckEl.style.cursor = (isMyTurnNow && gameData.turnPhase === 'PICK') ? 'pointer' : 'default';
            
            // Render hand
            const handDiv = document.getElementById('hand-container');
            handDiv.innerHTML = '';
            const myHand = gameData.players[myId].hand || [];
            
            // FIXED: Sort hand by value for better UX
            const sortedHand = [...myHand].sort((a, b) => {
                if(a.isJoker) return -1;
                if(b.isJoker) return 1;
                return a.val - b.val;
            });
            
            sortedHand.forEach((card, idx) => {
                // Find original index for selection tracking
                const originalIdx = myHand.findIndex(c => 
                    c.val === card.val && c.suit === card.suit && c.display === card.display
                );
                
                let div = document.createElement('div');
                div.className = `card ${card.color}`;
                if(selectedCardIndices.includes(originalIdx)) div.classList.add('selected');
                div.innerHTML = renderCardInner(card);
                div.onclick = () => toggleSelect(originalIdx, card);
                div.style.cursor = (isMyTurnNow && gameData.turnPhase === 'DISCARD') ? 'pointer' : 'default';
                handDiv.appendChild(div);
            });
            
            const sum = calculateHandSum(myHand);
            document.getElementById('hand-sum').innerText = `Sum: ${sum}`;
            
            // FIXED: Button states
            const btnDiscard = document.getElementById('btn-discard');
            const btnShow = document.getElementById('btn-show');
            const pickHint = document.getElementById('pick-hint');
            
            btnDiscard.disabled = true;
            btnShow.disabled = true;
            pickHint.style.display = 'none';
            
            if(isMyTurnNow) {
                if(gameData.turnPhase === 'DISCARD') {
                    // Enable discard if valid selection
                    if(selectedCardIndices.length > 0) {
                        const selectedCards = selectedCardIndices.map(i => myHand[i]);
                        const firstVal = selectedCards[0].val;
                        if(selectedCards.every(c => c.val === firstVal)) {
                            btnDiscard.disabled = false;
                        }
                    }
                    // Enable show if sum <= 5
                    if(sum <= 5) {
                        btnShow.disabled = false;
                    }
                } else if(gameData.turnPhase === 'PICK') {
                    pickHint.style.display = 'block';
                    pickHint.innerText = 'ðŸ‘† Pick from DECK or TRAY';
                }
            }
        }

        function renderScoreboard() {
            const isHost = (gameData.host === myId);
            const nextBtn = document.getElementById('next-round-btn');
            nextBtn.style.display = isHost ? 'inline-block' : 'none';
            
            const table = document.getElementById('score-table');
            const pIds = Object.keys(gameData.players);
            const lastRes = gameData.lastRoundData || {};
            
            let html = `<tr><th>Round</th>`;
            pIds.forEach(id => {
                html += `<th>${gameData.players[id].name}</th>`;
            });
            html += `</tr>`;
            
            // FIXED: Show all completed rounds
            const roundsCompleted = gameData.round;
            for(let r = 0; r < roundsCompleted; r++) {
                html += `<tr><td><strong>${r + 1}</strong></td>`;
                pIds.forEach(pid => {
                    const history = gameData.players[pid].history || [];
                    const score = history[r];
                    let cellClass = '';
                    
                    // Highlight last round results
                    if(r === roundsCompleted - 1 && lastRes.round === roundsCompleted) {
                        if(lastRes.winners && lastRes.winners.includes(pid)) {
                            cellClass = 'winner-hl';
                        }
                        if(lastRes.loser === pid) {
                            cellClass = 'loser-hl';
                        }
                    }
                    
                    html += `<td class="${cellClass}">${score !== undefined ? score : '-'}</td>`;
                });
                html += `</tr>`;
            }
            
            // Total row
            html += `<tr class="total-row"><td><strong>TOTAL</strong></td>`;
            pIds.forEach(pid => {
                html += `<td><strong>${gameData.players[pid].score || 0}</strong></td>`;
            });
            html += `</tr>`;
            
            table.innerHTML = html;
        }

        function isMyTurn() {
            if(!gameData) return false;
            const pIds = Object.keys(gameData.players);
            return pIds[gameData.turnIndex] === myId;
        }

        function toggleSelect(idx, card) {
            if(gameData.turnPhase !== 'DISCARD' || !isMyTurn()) return;
            if(selectedCardIndices.includes(idx)) {
                selectedCardIndices = selectedCardIndices.filter(i => i !== idx);
            } else {
                if(selectedCardIndices.length === 0) selectedCardIndices.push(idx);
                else {
                    const first = gameData.players[myId].hand[selectedCardIndices[0]];
                    if(first.val === card.val) selectedCardIndices.push(idx);
                    else selectedCardIndices = [idx];
                }
            }
            renderGame();
        }

        function calculateHandSum(hand) { 
            if(!hand) return 0;
            return hand.reduce((s, c) => s + (c.isJoker ? 0 : c.val), 0); 
        }

        const SUITS = ['â™¥', 'â™¦', 'â™£', 'â™ '];
        function createDeck() {
            let d = [];
            for(let i=0; i<2; i++) {
                SUITS.forEach(s => {
                    for(let n=1; n<=13; n++) {
                        let disp = n===1?'A':n===11?'J':n===12?'Q':n===13?'K':n;
                        d.push({val:n, suit:s, display:disp, color: (s=='â™¥'||s=='â™¦')?'red':'black', isJoker:false});
                    }
                });
            }
            for(let j=0; j<5; j++) d.push({val:0, suit:'â˜…', display:'JK', color:'purple', isJoker:true});
            return shuffle(d);
        }
        function shuffle(array) {
            const arr = [...array]; // Don't mutate original
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function renderCardInner(c) {
            return `<div class="card-corner">${c.display}<br>${c.suit}</div>
                    <div class="card-center">${c.suit}</div>
                    <div class="card-corner bottom">${c.display}<br>${c.suit}</div>`;
        }
        function renderCardHTML(c) { return `<div class="card ${c.color}" style="position:absolute;">${renderCardInner(c)}</div>`; }

        function showScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active-screen'));
            document.getElementById(id).classList.add('active-screen');
        }
        function showToast(msg) {
            const t = document.getElementById('toast');
            t.innerText = msg; t.style.opacity = 1;
            setTimeout(() => t.style.opacity=0, 3000);
        }
        function copyLink() {
            const url = `${window.location.origin}${window.location.pathname}?room=${roomId}`;
            navigator.clipboard.writeText(url).then(() => showToast("Link Copied"));
        }
        function exitGame() { window.location.reload(); }
    </script>
</body>
</html>