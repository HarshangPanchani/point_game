<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Points Game</title>
    <style>
        :root {
            --table-bg: #014222;
            --card-bg: #fefefe;
            --card-border: #333;
            --text-light: #fff;
            --text-dark: #000;
            --red-suit: #d90429;
            --black-suit: #000;
            --button-primary: #2a9d8f;
            --button-danger: #e76f51;
            --button-action: #f4a261;
            --button-disabled: #cccccc;
            --accent-color: #e9c46a;
            --bg-color: #013220;
        }

        body {
            font-family: 'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-light);
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            -webkit-tap-highlight-color: transparent;
        }

        .screen { display: none; }
        .screen.active { display: flex; }

        #app-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        
        /* Landscape Orientation Lock */
        @media (orientation: portrait) {
            #orientation-warning {
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                text-align: center;
                padding: 20px;
                font-size: 1.2em;
                background-color: var(--bg-color);
                color: var(--text-light);
                position: fixed;
                top: 0; left: 0; right: 0; bottom: 0;
                z-index: 10000;
            }
            #app-container { display: none; }
        }

        @media (orientation: landscape) {
            #orientation-warning { display: none; }
            #app-container { display: flex; }
        }

        /* Lobby Screen Styling */
        #lobby-screen {
            flex-direction: column;
            gap: 20px;
            padding: 20px;
            background-color: var(--table-bg);
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
            width: clamp(300px, 90vw, 500px);
        }

        h1, h2 {
            margin: 0 0 10px 0;
            text-align: center;
            color: var(--accent-color);
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
        }

        input[type="text"], input[type="number"] {
            padding: 12px;
            border-radius: 8px;
            border: 2px solid var(--accent-color);
            background: #f0f0f0;
            font-size: 1em;
            text-align: center;
        }
        
        label {
            font-size: 0.9em;
            color: var(--text-light);
            text-align: center;
        }

        button {
            padding: 15px 20px;
            border: none;
            border-radius: 8px;
            background-color: var(--button-primary);
            color: var(--text-light);
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
        }

        button:hover {
            background-color: #248a7e;
        }

        button:active {
            transform: scale(0.98);
        }
        
        button:disabled {
            background-color: var(--button-disabled);
            cursor: not-allowed;
        }

        #join-actions {
            display: flex;
            gap: 10px;
        }
        #join-game-code { text-transform: uppercase; }

        /* Game Screen Styling */
        #game-screen {
            width: 100%;
            height: 100%;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            box-sizing: border-box;
            background: radial-gradient(circle, #025a30, var(--table-bg));
        }

        .game-area {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-grow: 1;
            gap: 20px;
            padding: 10px;
            box-sizing: border-box;
        }
        
        .card-pile {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .card, .card-back {
            width: 60px;
            height: 90px;
            border-radius: 6px;
            background-color: var(--card-bg);
            border: 1px solid var(--card-border);
            color: var(--text-dark);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            font-size: 24px;
            font-weight: bold;
            padding: 4px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
            position: relative;
            cursor: pointer;
            user-select: none;
            box-sizing: border-box;
        }
        
        .card.joker {
             font-size: 18px;
             align-items: center;
             justify-content: center;
        }

        .card-back {
            background: linear-gradient(135deg, #4682b4, #5a9bd5);
            border: 5px solid white;
        }
        
        .card-back::after {
            content: "üÉè";
            font-size: 40px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .card.red { color: var(--red-suit); }
        .card.black { color: var(--black-suit); }

        .card-value {
            line-height: 1;
        }
        .card-suit {
            font-size: 16px;
            align-self: center;
        }
        .card-top { align-self: flex-start; }
        .card-bottom { align-self: flex-end; transform: rotate(180deg); }

        #player-hand {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
            width: 100%;
            box-sizing: border-box;
            overflow-x: auto;
            min-height: 120px;
        }

        #player-hand .card {
            transition: transform 0.2s, box-shadow 0.2s;
            margin: 0 -15px;
        }

        #player-hand .card:hover {
            transform: translateY(-15px);
        }
        
        #player-hand .card.selected {
            transform: translateY(-20px);
            box-shadow: 0 0 15px var(--accent-color);
            border: 2px solid var(--accent-color);
        }
        
        .game-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 8px;
            text-align: left;
        }
        
        .game-controls {
            display: flex;
            gap: 15px;
            padding: 10px;
        }
        
        #action-button { background-color: var(--button-action); }
        #show-button { background-color: var(--button-danger); }
        
        /* Waiting Overlay */
        #waiting-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            color: white;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 1.5em;
            z-index: 1000;
            flex-direction: column;
            gap: 20px;
        }
        
        #game-code-display {
            font-size: 1.2em;
            background: var(--accent-color);
            color: var(--text-dark);
            padding: 10px 20px;
            border-radius: 8px;
            font-family: monospace;
            cursor: pointer;
        }
        
        #players-list {
            list-style: none;
            padding: 0;
        }
        
        #players-list li {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .kick-button {
            background: var(--button-danger);
            color: white;
            border: none;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            cursor: pointer;
            font-weight: bold;
            padding: 0;
            line-height: 25px;
        }
        
        /* Scoreboard */
        #scoreboard-modal {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }
        
        #scoreboard-content {
            background: var(--bg-color);
            border: 2px solid var(--accent-color);
            border-radius: 12px;
            padding: 20px;
            width: 90vw;
            max-height: 90vh;
            overflow: auto;
        }
        
        #scoreboard-table {
            width: 100%;
            border-collapse: collapse;
            color: var(--text-light);
        }
        
        #scoreboard-table th, #scoreboard-table td {
            padding: 8px 12px;
            border: 1px solid var(--accent-color);
            text-align: center;
        }
        
        #scoreboard-table th {
            background: var(--table-bg);
            color: var(--accent-color);
        }

        #scoreboard-table tfoot td {
            font-weight: bold;
            background: var(--accent-color);
            color: var(--text-dark);
        }
        
        #close-scoreboard {
            margin-top: 15px;
            width: 100%;
        }

    </style>
</head>
<body>

    <div id="orientation-warning">
        <p>Please rotate your device to landscape mode to play.</p>
    </div>

    <div id="app-container">
        <!-- Lobby Screen -->
        <div id="lobby-screen" class="screen active">
            <h1>Points Game</h1>
            <div class="input-group">
                <input type="text" id="player-name" placeholder="Enter Your Name">
            </div>
            <div class="input-group">
                <h2>Create a New Game</h2>
                <label for="late-penalty">Late Joiner Penalty Score</label>
                <input type="number" id="late-penalty" value="10">
                <button id="create-game-btn">Create Game</button>
            </div>
            <hr style="width:100%; border-color: var(--accent-color);">
            <div class="input-group">
                <h2>Join a Game</h2>
                <div id="join-actions">
                    <input type="text" id="join-game-code" placeholder="Enter Game Code">
                    <button id="join-game-btn">Join</button>
                </div>
            </div>
        </div>

        <!-- Game Screen -->
        <div id="game-screen" class="screen">
            <div class="game-info">
                <div id="game-status">Current Turn: ...</div>
                <div id="hand-sum">Your Hand Sum: 0</div>
            </div>

            <div class="game-area">
                <div class="card-pile">
                    <span>Draw Pile</span>
                    <div id="draw-pile" class="card-back"></div>
                    <span id="draw-pile-count">109</span>
                </div>
                <div class="card-pile">
                    <span>Tray (Discard)</span>
                    <div id="tray-pile" class="card"></div>
                    <span id="tray-pile-count">0</span>
                </div>
            </div>

            <div id="player-hand">
                <!-- Player's cards will be rendered here -->
            </div>

            <div class="game-controls">
                <button id="show-button">Show</button>
                <button id="action-button">Discard</button>
                <button id="scoreboard-button">Scoreboard</button>
            </div>
        </div>

        <!-- Waiting Overlay -->
        <div id="waiting-overlay" class="screen">
             <h2>Waiting for players...</h2>
             <p>Share this code or link with your friends:</p>
             <div id="game-code-display">CODE</div>
             <ul id="players-list"></ul>
             <button id="start-game-btn">Start Game</button>
             <p id="share-link-message" style="display:none;"></p>
        </div>
        
        <!-- Scoreboard Modal -->
        <div id="scoreboard-modal" class="screen">
            <div id="scoreboard-content">
                <h2>Scoreboard</h2>
                <table id="scoreboard-table">
                    <thead></thead>
                    <tbody></tbody>
                    <tfoot></tfoot>
                </table>
                <button id="close-scoreboard">Close</button>
            </div>
        </div>
    </div>

    <script type="module">
      // Import the functions you need from the SDKs you need
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
      import { getDatabase, ref, set, onValue, get, update, remove } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";

      // Your web app's Firebase configuration
      const firebaseConfig = {
        apiKey: "AIzaSyAZ7-gmZfu6nfRvY-4hqdqQ86lGE405RQU",
        authDomain: "pointgame-281d5.firebaseapp.com",
        databaseURL: "https://pointgame-281d5-default-rtdb.asia-southeast1.firebasedatabase.app/",
        projectId: "pointgame-281d5",
        storageBucket: "pointgame-281d5.appspot.com",
        messagingSenderId: "1006005693168",
        appId: "1:1006005693168:web:e26847ed3f4371146bf035"
      };

      // Initialize Firebase
      const app = initializeApp(firebaseConfig);
      const db = getDatabase(app);

      // --- DOM Elements ---
      const lobbyScreen = document.getElementById('lobby-screen');
      const gameScreen = document.getElementById('game-screen');
      const waitingOverlay = document.getElementById('waiting-overlay');
      const scoreboardModal = document.getElementById('scoreboard-modal');
      
      const playerNameInput = document.getElementById('player-name');
      const createGameBtn = document.getElementById('create-game-btn');
      const joinGameBtn = document.getElementById('join-game-btn');
      const joinGameCodeInput = document.getElementById('join-game-code');
      const latePenaltyInput = document.getElementById('late-penalty');
      
      const gameCodeDisplay = document.getElementById('game-code-display');
      const playersList = document.getElementById('players-list');
      const startGameBtn = document.getElementById('start-game-btn');
      
      const gameStatus = document.getElementById('game-status');
      const handSumEl = document.getElementById('hand-sum');
      const drawPile = document.getElementById('draw-pile');
      const drawPileCount = document.getElementById('draw-pile-count');
      const trayPile = document.getElementById('tray-pile');
      const trayPileCount = document.getElementById('tray-pile-count');
      const playerHand = document.getElementById('player-hand');
      
      const actionButton = document.getElementById('action-button');
      const showButton = document.getElementById('show-button');
      const scoreboardButton = document.getElementById('scoreboard-button');
      const closeScoreboardButton = document.getElementById('close-scoreboard');
      
      // --- Local State ---
      let localPlayerId = null;
      let localGameCode = null;
      let isHost = false;
      let selectedCards = [];

      // --- Firebase Refs ---
      let gameRef = null;
      let playersRef = null;
      let gameStateRef = null;
      
      // --- Game Constants ---
      const SUITS = ['‚ô•', '‚ô¶', '‚ô£', '‚ô†'];
      const VALUES = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];

      // --- Core Functions ---

      function createDeck() {
          let deck = [];
          // 2 standard decks
          for (let i = 0; i < 2; i++) {
              for (const suit of SUITS) {
                  for (const value of VALUES) {
                      deck.push({ value, suit });
                  }
              }
          }
          // 5 Jokers
          for (let i = 0; i < 5; i++) {
              deck.push({ value: 'Joker', suit: 'üÉè' });
          }
          return deck;
      }
      
      function getCardPointValue(card) {
          if (card.value === 'Joker') return 0;
          if (card.value === 'A') return 1;
          if (['J', 'Q', 'K'].includes(card.value)) {
              return { 'J': 11, 'Q': 12, 'K': 13 }[card.value];
          }
          return parseInt(card.value);
      }
      
      function calculateHandSum(hand) {
          if (!hand || hand.length === 0) return 0;
          return hand.reduce((sum, card) => sum + getCardPointValue(card), 0);
      }

      function generateGameCode() {
          return Math.random().toString(36).substring(2, 8).toUpperCase();
      }
      
      function switchScreen(screen) {
          document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
          screen.classList.add('active');
      }
      
      function renderCard(card, isTrayCard = false) {
          const cardEl = document.createElement('div');
          cardEl.className = 'card';
          
          if (!card || !card.value) {
            cardEl.style.visibility = 'hidden';
            return cardEl;
          }

          const pointValue = getCardPointValue(card);
          cardEl.dataset.value = card.value;
          cardEl.dataset.suit = card.suit;
          cardEl.dataset.pointValue = pointValue;
          
          if (card.value === 'Joker') {
              cardEl.classList.add('joker');
              cardEl.innerHTML = `<span>JOKER</span>`;
          } else {
              const color = ['‚ô•', '‚ô¶'].includes(card.suit) ? 'red' : 'black';
              cardEl.classList.add(color);
              cardEl.innerHTML = `
                  <div class="card-top">
                      <div class="card-value">${card.value}</div>
                      <div class="card-suit">${card.suit}</div>
                  </div>
                  <div class="card-bottom">
                      <div class="card-value">${card.value}</div>
                      <div class="card-suit">${card.suit}</div>
                  </div>
              `;
          }
          
          if(!isTrayCard) {
            cardEl.addEventListener('click', () => toggleCardSelection(cardEl));
          }
          
          return cardEl;
      }
      
      function updateUI(gameData) {
        if (gameData.status === 'lobby') {
            switchScreen(waitingOverlay);
            gameCodeDisplay.textContent = localGameCode;
            
            // Share Link logic
            const url = window.location.href.split('?')[0] + '?gameCode=' + localGameCode;
            gameCodeDisplay.onclick = () => {
                navigator.clipboard.writeText(url).then(() => {
                    document.getElementById('share-link-message').textContent = 'Link copied to clipboard!';
                    document.getElementById('share-link-message').style.display = 'block';
                    setTimeout(() => { document.getElementById('share-link-message').style.display = 'none'; }, 2000);
                });
            };

            playersList.innerHTML = '';
            const playerIds = Object.keys(gameData.players);
            playerIds.forEach(pid => {
                const player = gameData.players[pid];
                const li = document.createElement('li');
                li.textContent = `${player.name} ${pid === gameData.hostId ? '(Host)' : ''}`;
                if (isHost && pid !== localPlayerId) {
                    const kickBtn = document.createElement('button');
                    kickBtn.textContent = 'X';
                    kickBtn.className = 'kick-button';
                    kickBtn.onclick = () => kickPlayer(pid);
                    li.appendChild(kickBtn);
                }
                playersList.appendChild(li);
            });
            startGameBtn.style.display = isHost && playerIds.length > 1 ? 'block' : 'none';
        } else if (gameData.status === 'playing' || gameData.status === 'round_over') {
            switchScreen(gameScreen);
            
            const myTurn = gameData.currentTurn === localPlayerId;
            const currentPlayerName = gameData.players[gameData.currentTurn]?.name || '';
            gameStatus.textContent = myTurn ? "It's Your Turn!" : `Waiting for ${currentPlayerName}...`;
            
            const me = gameData.players[localPlayerId];
            playerHand.innerHTML = '';
            if (me && me.hand) {
                me.hand.forEach(card => playerHand.appendChild(renderCard(card)));
            }
            
            const handSum = calculateHandSum(me?.hand);
            handSumEl.textContent = `Your Hand Sum: ${handSum}`;
            
            drawPileCount.textContent = gameData.drawPile.length;
            trayPileCount.textContent = gameData.tray.length;
            
            if (gameData.tray.length > 0) {
                const topCard = gameData.tray[gameData.tray.length - 1];
                trayPile.innerHTML = renderCard(topCard, true).innerHTML;
                trayPile.className = renderCard(topCard, true).className;
                trayPile.style.visibility = 'visible';
            } else {
                trayPile.style.visibility = 'hidden';
            }
            
            // Controls Logic
            const turnPhase = gameData.turnPhase;
            actionButton.disabled = !myTurn;
            showButton.disabled = !myTurn || handSum > 5 || turnPhase !== 'discard';
            
            if (myTurn) {
                if (turnPhase === 'discard') {
                    actionButton.textContent = 'Discard';
                } else if (turnPhase === 'pick') {
                    actionButton.textContent = 'End Turn (Waiting for pick)';
                    actionButton.disabled = true;
                }
            } else {
                actionButton.textContent = 'Discard';
            }
            
            // Round over logic
            if (gameData.status === 'round_over') {
                gameStatus.textContent = `Round Over! ${gameData.roundMessage}`;
                setTimeout(() => {
                    renderScoreboard(gameData);
                    scoreboardModal.classList.add('active');
                    if (isHost) {
                        setTimeout(startNewRound, 5000); // Host automatically starts next round after a delay
                    }
                }, 2000);
            }
        }
      }
      
      function renderScoreboard(gameData) {
          const tableHead = scoreboardModal.querySelector('thead');
          const tableBody = scoreboardModal.querySelector('tbody');
          const tableFoot = scoreboardModal.querySelector('tfoot');
          
          tableHead.innerHTML = '';
          tableBody.innerHTML = '';
          tableFoot.innerHTML = '';
          
          const playerIds = Object.keys(gameData.players);
          const headerRow = document.createElement('tr');
          headerRow.innerHTML = `<th>Round</th>` + playerIds.map(pid => `<th>${gameData.players[pid].name}</th>`).join('');
          tableHead.appendChild(headerRow);
          
          const totals = playerIds.reduce((acc, pid) => ({...acc, [pid]: 0}), {});
          
          for (let i = 1; i <= gameData.currentRound; i++) {
              const bodyRow = document.createElement('tr');
              let rowHtml = `<td>${i}</td>`;
              playerIds.forEach(pid => {
                  const score = gameData.scores?.[i]?.[pid] ?? 0;
                  rowHtml += `<td>${score}</td>`;
                  totals[pid] += score;
              });
              bodyRow.innerHTML = rowHtml;
              tableBody.appendChild(bodyRow);
          }
          
          const footerRow = document.createElement('tr');
          footerRow.innerHTML = `<td><b>TOTAL</b></td>` + playerIds.map(pid => `<td><b>${totals[pid]}</b></td>`).join('');
          tableFoot.appendChild(footerRow);
      }
      
      function toggleCardSelection(cardEl) {
          const cardData = { value: cardEl.dataset.value, suit: cardEl.dataset.suit };
          const index = selectedCards.findIndex(c => c.value === cardData.value && c.suit === cardData.suit);

          if (index > -1) {
              selectedCards.splice(index, 1);
              cardEl.classList.remove('selected');
          } else {
              cardEl.classList.add('selected');
              selectedCards.push(cardData);
          }
      }

      function handleAction() {
        if (selectedCards.length === 0) {
            alert('You must select at least one card to discard.');
            return;
        }

        const firstValue = selectedCards[0].value;
        if (!selectedCards.every(c => c.value === firstValue)) {
            alert('You can only discard cards of the same value.');
            // Clear selection
            playerHand.querySelectorAll('.card.selected').forEach(c => c.classList.remove('selected'));
            selectedCards = [];
            return;
        }

        // Perform discard
        get(gameRef).then(snapshot => {
            const gameData = snapshot.val();
            if (!gameData || gameData.currentTurn !== localPlayerId || gameData.turnPhase !== 'discard') return;

            const player = gameData.players[localPlayerId];
            const newHand = player.hand.filter(handCard => 
                !selectedCards.some(selCard => selCard.value === handCard.value && selCard.suit === handCard.suit)
            );
            
            const newTray = [...(gameData.tray || []), ...selectedCards];

            update(gameRef, {
                [`players/${localPlayerId}/hand`]: newHand,
                'tray': newTray,
                'turnPhase': 'pick'
            });

            selectedCards = [];
        });
      }

      function handlePick(source) {
        get(gameRef).then(snapshot => {
            const gameData = snapshot.val();
            if (!gameData || gameData.currentTurn !== localPlayerId || gameData.turnPhase !== 'pick') return;

            let pickedCard;
            let updates = {};
            let player = gameData.players[localPlayerId];

            if (source === 'draw') {
                if (gameData.drawPile.length === 0) {
                    alert("Draw pile is empty!"); // Should ideally reshuffle tray
                    return;
                }
                pickedCard = gameData.drawPile.pop();
                updates.drawPile = gameData.drawPile;
            } else if (source === 'tray') {
                 if (gameData.tray.length === 0) return;
                 pickedCard = gameData.tray.pop();
                 updates.tray = gameData.tray;
            }

            const newHand = [...(player.hand || []), pickedCard];
            updates[`players/${localPlayerId}/hand`] = newHand;
            
            // End turn
            const playerIds = Object.keys(gameData.players);
            const currentIndex = playerIds.indexOf(localPlayerId);
            const nextIndex = (currentIndex + 1) % playerIds.length;
            updates.currentTurn = playerIds[nextIndex];
            updates.turnPhase = 'discard';

            update(gameRef, updates);
        });
      }

      function handleShow() {
        get(gameRef).then(snapshot => {
            const gameData = snapshot.val();
            const me = gameData.players[localPlayerId];
            const mySum = calculateHandSum(me.hand);

            if (mySum > 5) {
                alert("You can only 'Show' if your hand sum is 5 or less.");
                return;
            }

            // Calculate everyone's score
            let playerScores = {};
            let winners = [];
            Object.entries(gameData.players).forEach(([pid, player]) => {
                playerScores[pid] = { sum: calculateHandSum(player.hand), name: player.name };
            });

            // Find players with a sum lower or equal to the shower's sum
            Object.entries(playerScores).forEach(([pid, data]) => {
                if (data.sum <= mySum) {
                    winners.push(pid);
                }
            });

            const round = gameData.currentRound;
            const updates = {
                status: 'round_over',
                [`scores/${round}`]: {}
            };
            
            let message = "";

            if (winners.length === 1 && winners[0] === localPlayerId) { // Clean win
                message = `${me.name} wins the round!`;
                Object.keys(gameData.players).forEach(pid => {
                    updates[`scores/${round}`][pid] = (pid === localPlayerId) ? 0 : playerScores[pid].sum;
                });
            } else { // Wrong show or tie
                const peopleWhoBeatMe = winners.filter(pid => pid !== localPlayerId);
                const isZeroZeroTie = mySum === 0 && peopleWhoBeatMe.some(pid => playerScores[pid].sum === 0);
                
                if (isZeroZeroTie) {
                    message = `A 0-0 tie! Both players get 0 points.`;
                } else {
                     message = `${me.name} made a wrong show!`;
                }

                Object.keys(gameData.players).forEach(pid => {
                    if (playerScores[pid].sum <= mySum) { // This player is a winner
                        updates[`scores/${round}`][pid] = 0;
                    } else if (pid === localPlayerId) { // The shower is the loser
                        updates[`scores/${round}`][pid] = 30 * peopleWhoBeatMe.length;
                    } else { // Other players
                        updates[`scores/${round}`][pid] = playerScores[pid].sum;
                    }
                });
            }
            updates.roundMessage = message;
            update(gameRef, updates);
        });
      }
      
      function startNewRound() {
        get(gameRef).then(snapshot => {
            if (!snapshot.exists()) return;
            const gameData = snapshot.val();
            
            let deck = createDeck();
            // Shuffle
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }

            const playerIds = Object.keys(gameData.players);
            const updates = {};
            playerIds.forEach(pid => {
                updates[`players/${pid}/hand`] = deck.splice(0, 7);
            });
            
            updates.tray = [deck.pop()];
            updates.drawPile = deck;
            updates.status = 'playing';
            updates.turnPhase = 'discard';
            updates.currentRound = gameData.currentRound + 1;
            // Next round's starting player can be rotated if desired, here it just defaults to host
            updates.currentTurn = gameData.hostId;
            
            update(gameRef, updates);
        });
      }

      function kickPlayer(playerIdToKick) {
        if (!isHost) return;
        
        get(gameRef).then(snapshot => {
            const gameData = snapshot.val();
            
            const updates = {};
            updates[`players/${playerIdToKick}`] = null;
            
            // Remove from scores too
            if (gameData.scores) {
                Object.keys(gameData.scores).forEach(round => {
                    updates[`scores/${round}/${playerIdToKick}`] = null;
                });
            }
            
            update(gameRef, updates);
        });
      }


      // --- Event Listeners ---
      createGameBtn.addEventListener('click', () => {
          const playerName = playerNameInput.value.trim();
          if (!playerName) {
              alert('Please enter your name.');
              return;
          }

          localPlayerId = 'player_' + Date.now();
          localGameCode = generateGameCode();
          isHost = true;
          
          gameRef = ref(db, 'games/' + localGameCode);
          playersRef = ref(db, 'games/' + localGameCode + '/players');
          gameStateRef = ref(db, 'games/' + localGameCode + '/status');
          
          set(gameRef, {
              hostId: localPlayerId,
              status: 'lobby',
              latePenalty: parseInt(latePenaltyInput.value) || 10,
              players: {
                  [localPlayerId]: { name: playerName }
              },
              currentRound: 0,
              scores: {}
          });
          
          onValue(gameRef, (snapshot) => {
              if (snapshot.exists()) {
                  updateUI(snapshot.val());
              } else {
                  alert('Game has been closed by the host.');
                  window.location.reload();
              }
          });
      });
      
      joinGameBtn.addEventListener('click', () => {
          const playerName = playerNameInput.value.trim();
          const gameCode = joinGameCodeInput.value.trim().toUpperCase();

          if (!playerName || !gameCode) {
              alert('Please enter your name and a game code.');
              return;
          }

          localPlayerId = 'player_' + Date.now();
          localGameCode = gameCode;
          isHost = false;
          
          gameRef = ref(db, 'games/' + localGameCode);

          get(gameRef).then(snapshot => {
              if (snapshot.exists()) {
                  const gameData = snapshot.val();
                  const updates = {};
                  updates[`players/${localPlayerId}`] = { name: playerName };

                  // Late joiner penalty
                  if (gameData.status === 'playing' || gameData.status === 'round_over') {
                      for (let i = 1; i <= gameData.currentRound; i++) {
                         updates[`scores/${i}/${localPlayerId}`] = gameData.latePenalty;
                      }
                  }

                  update(ref(db, `games/${gameCode}`), updates);

                  onValue(gameRef, (snapshot) => {
                      if (snapshot.exists()) {
                          const latestGameData = snapshot.val();
                          // Check if kicked
                          if (!latestGameData.players || !latestGameData.players[localPlayerId]) {
                              alert("You have been kicked from the game.");
                              window.location.reload();
                          } else {
                              updateUI(latestGameData);
                          }
                      } else {
                         alert('Game not found or has ended.');
                         window.location.reload();
                      }
                  });
              } else {
                  alert('Game code not found.');
              }
          });
      });
      
      startGameBtn.addEventListener('click', () => {
          if (!isHost) return;
          
          get(gameRef).then(snapshot => {
            const gameData = snapshot.val();
            const playerIds = Object.keys(gameData.players);
            if(playerIds.length < 2) {
                alert("You need at least 2 players to start.");
                return;
            }
            
            update(gameRef, {
                currentTurn: localPlayerId,
                currentRound: 0 // Will be incremented to 1 by startNewRound
            }).then(startNewRound);
          });
      });

      // Check for game code in URL on page load
      window.addEventListener('load', () => {
          const params = new URLSearchParams(window.location.search);
          const gameCode = params.get('gameCode');
          if (gameCode) {
              joinGameCodeInput.value = gameCode;
          }
      });
      
      actionButton.addEventListener('click', handleAction);
      showButton.addEventListener('click', handleShow);
      drawPile.addEventListener('click', () => handlePick('draw'));
      trayPile.addEventListener('click', () => handlePick('tray'));
      scoreboardButton.addEventListener('click', () => {
          get(gameRef).then(snapshot => {
              if(snapshot.exists()) {
                  renderScoreboard(snapshot.val());
                  scoreboardModal.classList.add('active');
              }
          });
      });
      closeScoreboardButton.addEventListener('click', () => scoreboardModal.classList.remove('active'));

    </script>
</body>
</html>