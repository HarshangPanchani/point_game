<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>POINT - The Greatest Card Game</title>
    <!-- Firebase SDK -->
    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
      import { getDatabase, ref, set, onValue, get, update, onDisconnect, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";
      window.firebaseSDK = { initializeApp, getDatabase, ref, set, onValue, get, update, onDisconnect, serverTimestamp };
    </script>
    <style>
        :root {
            --bg-color: #013220; /* Darker Felt Green */
            --table-color: #014222;
            --card-width: 70px;
            --card-height: 98px;
            --text-light: #f0f0f0;
            --accent: #FFD700; /* Gold */
            --danger: #d90429;
            --primary: #2a9d8f;
        }

        * { box-sizing: border-box; user-select: none; -webkit-user-select: none; -webkit-tap-highlight-color: transparent; }
        body {
            margin: 0; padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-light);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        /* Landscape Warning */
        #portrait-warning {
            display: none;
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #1a1a1a;
            z-index: 9999;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
        }
        @media (orientation: portrait) {
            #portrait-warning { display: flex; }
        }

        /* Screens */
        .screen {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%; height: 100%;
            position: absolute; top: 0; left: 0;
            padding: 10px;
            overflow-y:auto;
            transition: opacity 0.3s;
        }
        .active-screen { display: flex; }

        /* UI Elements */
        input, button {
            padding: 12px 18px;
            margin: 8px;
            border-radius: 8px;
            border: none;
            font-size: 16px;
            font-weight: bold;
        }
        button { 
            cursor: pointer; 
            background: var(--primary); 
            color: #fff; 
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s; 
            box-shadow: 
                0 4px 8px rgba(0,0,0,0.3),
                0 2px 4px rgba(0,0,0,0.2);
        }
        button:hover { 
            filter: brightness(1.1);
            box-shadow: 
                0 6px 12px rgba(0,0,0,0.4),
                0 3px 6px rgba(0,0,0,0.3);
        }
        button:active { 
            transform: scale(0.97); 
            box-shadow: 
                0 2px 4px rgba(0,0,0,0.3),
                0 1px 2px rgba(0,0,0,0.2);
        }
        button:disabled { 
            background: #999; 
            cursor: not-allowed; 
            color: #ccc; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        button.danger { background: var(--danger); }
        button.accent { background: var(--accent); color: #000; }
        input { color: #000; text-align: center; width: 100%; }

        /* Lobby */
        .lobby-box { background: rgba(0,0,0,0.3); padding: 20px; border-radius: 12px; width: clamp(300px, 90vw, 500px); }
        #lobby-list {
            list-style: none; padding: 0; width: 100%;
            background: rgba(0,0,0,0.3); border-radius: 10px; margin-top: 15px;
        }
        #lobby-list li {
            padding: 12px; border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex; justify-content: space-between; align-items: center;
        }
        #lobby-code-display { font-family: monospace; background: #fff; color: #000; padding: 5px 10px; border-radius: 5px; cursor: pointer; user-select: text; }

        /* Game Layout - Felt Texture Background */
        #game-screen { 
            background: 
                radial-gradient(circle at 20% 30%, rgba(1, 66, 34, 0.8), transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(1, 50, 32, 0.6), transparent 50%),
                repeating-linear-gradient(
                    0deg,
                    rgba(0, 0, 0, 0.03) 0px,
                    transparent 1px,
                    transparent 2px,
                    rgba(0, 0, 0, 0.03) 3px
                ),
                radial-gradient(circle, var(--table-color), var(--bg-color));
            position: relative;
        }
        #game-screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                repeating-linear-gradient(
                    90deg,
                    transparent,
                    transparent 2px,
                    rgba(0, 0, 0, 0.02) 2px,
                    rgba(0, 0, 0, 0.02) 4px
                );
            pointer-events: none;
            z-index: 0;
        }
        #game-ui {
            width: 100%; height: 100%;
            display: grid;
            grid-template-rows: 40px 1fr 140px;
            position: relative;
            z-index: 1;
        }

        /* Top Bar */
        #top-bar {
            background: rgba(0,0,0,0.5);
            display: flex; justify-content: space-between; align-items: center;
            padding: 0 20px; font-size: 14px;
        }
        #turn-indicator { font-weight: bold; color: var(--accent); }

        /* Center Table */
        #table-area {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        /* Arc Layout for Opponents */
        #opponents {
            position: absolute; 
            top: 10px; 
            width: 100%;
            height: 120px;
            display: flex; 
            justify-content: center;
            align-items: flex-start;
            perspective: 1000px;
        }
        .opponent {
            background: rgba(0,0,0,0.5);
            padding: 8px 12px; 
            border-radius: 12px;
            text-align: center; 
            font-size: 12px;
            border: 2px solid transparent;
            min-width: 90px;
            position: absolute;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            backdrop-filter: blur(5px);
        }
        .opponent.active-turn { 
            border: 2px solid var(--accent);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.6), 0 4px 8px rgba(0,0,0,0.3);
            animation: pulse-glow 2s ease-in-out infinite;
        }
        @keyframes pulse-glow {
            0%, 100% { 
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.6), 0 4px 8px rgba(0,0,0,0.3);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 0 30px rgba(255, 215, 0, 0.8), 0 4px 8px rgba(0,0,0,0.3);
                transform: scale(1.05);
            }
        }
        .opponent .card-icon { font-size: 18px; }

        .deck-placeholder {
            width: calc(var(--card-width) + 10px); 
            height: calc(var(--card-height) + 10px);
            border: 2px dashed rgba(255,255,255,0.5);
            border-radius: 8px; 
            margin: 0 20px;
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center;
            position: relative;
            background: rgba(0,0,0,0.2);
            cursor: pointer;
            transition: border-color 0.2s, transform 0.2s;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }
        .deck-placeholder.actionable { 
            border-style: solid; 
            border-color: var(--accent);
            box-shadow: 0 4px 12px rgba(0,0,0,0.4), 0 0 15px rgba(255, 215, 0, 0.3);
        }
        .deck-placeholder.actionable:hover { 
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(0,0,0,0.5), 0 0 20px rgba(255, 215, 0, 0.5);
        }
        .deck-placeholder span { 
            font-size: 12px; 
            text-align: center; 
            color: rgba(255,255,255,0.8); 
        }
        
        /* Pickable Tray Card Highlight */
        .deck-placeholder.pickable {
            border: 3px solid var(--accent);
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.7), 0 4px 12px rgba(0,0,0,0.4);
            animation: pickable-pulse 1.5s ease-in-out infinite;
        }
        @keyframes pickable-pulse {
            0%, 100% { 
                box-shadow: 0 0 25px rgba(255, 215, 0, 0.7), 0 4px 12px rgba(0,0,0,0.4);
            }
            50% { 
                box-shadow: 0 0 35px rgba(255, 215, 0, 0.9), 0 4px 12px rgba(0,0,0,0.4);
            }
        }

        /* Player Hand */
        #player-area {
            background: linear-gradient(transparent, rgba(0,0,0,0.8));
            display: flex; 
            flex-direction: column;
            align-items: center;
            padding-bottom: 5px;
        }
        #hand-container {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            margin-top: -35px;
            height: 110px;
            width: 100%;
            padding: 0 10px;
            overflow-x: auto;
            perspective: 1000px;
        }
        #controls { 
            display: flex; 
            gap: 10px; 
            margin-top: 5px; 
            align-items: center; 
        }
        
        /* Prominent Hand Sum Display - Poker Chip Style */
        #hand-sum-display {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 8px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #000;
            box-shadow: 
                0 4px 8px rgba(0,0,0,0.4),
                inset 0 2px 4px rgba(255,255,255,0.3),
                inset 0 -2px 4px rgba(0,0,0,0.2);
            border: 3px solid rgba(255,255,255,0.3);
            position: relative;
        }
        #hand-sum-display::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 2px solid rgba(0,0,0,0.2);
            box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
        }
        #hand-sum-display::after {
            content: 'SUM';
            position: absolute;
            top: -20px;
            font-size: 10px;
            color: var(--text-light);
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }

        /* Card Visuals - Enhanced Design with Depth */
        .card {
            width: var(--card-width); 
            height: var(--card-height);
            background: linear-gradient(135deg, #ffffff 0%, #f8f8f8 100%);
            color: #000;
            border-radius: 8px;
            display: flex; 
            flex-direction: column;
            justify-content: space-between;
            padding: 6px 7px;
            box-shadow: 
                0 4px 8px rgba(0,0,0,0.3),
                0 2px 4px rgba(0,0,0,0.2),
                inset 0 1px 0 rgba(255,255,255,0.5);
            font-weight: bold; 
            font-family: 'Arial', 'Georgia', serif;
            cursor: pointer;
            position: relative;
            margin: 0 -18px;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), border 0.2s, box-shadow 0.3s;
            border: 2px solid rgba(0,0,0,0.1);
            transform-style: preserve-3d;
        }
        #hand-container .card {
            transform-origin: center bottom;
        }
        #hand-container .card:hover { 
            transform: translateY(-20px) rotate(-2deg) scale(1.05);
            z-index: 10;
            box-shadow: 
                0 8px 16px rgba(0,0,0,0.4),
                0 4px 8px rgba(0,0,0,0.3),
                inset 0 1px 0 rgba(255,255,255,0.5);
        }
        .card.selected { 
            transform: translateY(-30px) rotate(-3deg) scale(1.08);
            border: 3px solid var(--accent);
            box-shadow: 
                0 8px 20px rgba(255, 215, 0, 0.5),
                0 4px 8px rgba(0,0,0,0.3),
                inset 0 1px 0 rgba(255,255,255,0.5);
            z-index: 15;
        }
        .card.red { color: var(--danger); }
        .card.black { color: #1a1a1a; }
        .card-center { 
            font-size: 36px; 
            align-self: center; 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%);
            text-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .card-corner { 
            font-size: 18px; 
            line-height: 1.1;
            font-weight: 900;
            text-shadow: 0 1px 1px rgba(0,0,0,0.1);
        }
        .card-corner.bottom { 
            transform: rotate(180deg); 
            align-self: flex-end; 
        }
        .card.joker .card-center { 
            font-size: 20px; 
            font-weight: bold; 
            letter-spacing: -1px; 
        }
        
        /* Card Animation Classes */
        .card.dealing {
            animation: deal-card 0.6s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }
        .card.discarding {
            animation: discard-card 0.5s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }
        .card.picking {
            animation: pick-card 0.5s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }
        .card.shake {
            animation: shake-invalid 0.5s ease-in-out;
        }
        
        @keyframes deal-card {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5) rotate(180deg);
            }
            100% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1) rotate(0deg);
            }
        }
        
        @keyframes discard-card {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translateY(100px) scale(0.8) rotate(10deg);
                opacity: 0;
            }
        }
        
        @keyframes pick-card {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.2) rotate(5deg);
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        @keyframes shake-invalid {
            0%, 100% { transform: translateX(0) rotate(0deg); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px) rotate(-2deg); }
            20%, 40%, 60%, 80% { transform: translateX(5px) rotate(2deg); }
        }
        
        .card-back {
            background: linear-gradient(135deg, #4682b4, #5a9bd5);
            border: 5px solid white;
        }
        .card-back::after { content: "üÉè"; font-size: 40px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }

        /* Scoreboard Table */
        #scoreboard-screen { background: rgba(0,0,0,0.85); backdrop-filter: blur(5px); }
        #scoreboard-container { background: var(--bg-color); border: 2px solid var(--accent); border-radius: 12px; padding: 20px; width: 95vw; max-width: 800px; max-height: 90vh; overflow: auto; }
        table { width: 100%; border-collapse: collapse; background: white; color: black; font-size: 14px; }
        th, td { border: 1px solid #ccc; padding: 8px; text-align: center; }
        th { background: #eee; }
        tfoot { font-weight: bold; font-size: 16px; }
        tfoot td { background: var(--accent); color: #000; }
        
        /* Notification */
        #toast {
            position: fixed; bottom: 150px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.9); color: white; padding: 12px 24px;
            border-radius: 25px; opacity: 0; pointer-events: none; transition: opacity 0.3s;
            z-index: 10000;
        }
    </style>
</head>
<body>

    <div id="portrait-warning">
        <h1>Please Rotate Your Device</h1>
        <p>This game is best played in Landscape mode.</p>
    </div>

    <!-- 1. Start Screen -->
    <div id="start-screen" class="screen active-screen">
        <div class="lobby-box">
            <h1>POINT</h1>
            <input type="text" id="username" placeholder="Enter Your Name" maxlength="12">
            <div>
                <button onclick="app.createLobby()" class="accent">Create Lobby</button>
                <button onclick="app.showJoinInput()">Join Lobby</button>
            </div>
            <div id="join-container" style="display:none; margin-top:10px;">
                <input type="text" id="room-code-input" placeholder="Enter Lobby Code" style="text-transform:uppercase;">
                <button onclick="app.joinLobby()">Connect</button>
            </div>
        </div>
    </div>

    <!-- 2. Lobby Screen -->
    <div id="lobby-screen" class="screen">
        <div class="lobby-box">
            <h2>Lobby Code: <span id="lobby-code-display" onclick="app.copyLobbyLink()">CODE</span></h2>
            <div id="host-settings" style="display:none; margin-bottom: 10px; text-align:center;">
                <label>Late Joiner Penalty Score: </label>
                <input type="number" id="late-penalty-input" value="10" style="width:80px; padding:8px;" onchange="app.updateSettings()">
            </div>
            <p>Players:</p>
            <ul id="lobby-list"></ul>
            <div id="lobby-controls" style="text-align:center;">
                <button id="start-game-btn" style="display:none" onclick="app.startGame()" class="accent">Start Game</button>
            </div>
            <p id="waiting-text" style="text-align:center; font-style:italic;">Waiting for host to start...</p>
        </div>
    </div>

    <!-- 3. Game Screen -->
    <div id="game-screen" class="screen">
        <div id="game-ui">
            <div id="top-bar">
                <span>Room: <span id="game-room-id"></span></span>
                <span id="round-indicator">Round: 1</span>
                <span id="turn-indicator">Waiting...</span>
            </div>

            <div id="table-area">
                <div id="opponents"></div>
                <div class="deck-placeholder" id="draw-pile" onclick="app.pickCard('draw')">
                    <div id="draw-pile-visual" class="card card-back" style="position: absolute;"></div>
                    <span>DRAW (<span id="draw-count">0</span>)</span>
                </div>
                <div class="deck-placeholder" id="discard-pile" onclick="app.pickCard('tray')">
                    <div id="discard-pile-visual"><span>TRAY<br>(Empty)</span></div>
                </div>
            </div>

            <div id="player-area">
                <div id="hand-sum-display"></div>
                <div id="hand-container"></div>
                <div id="controls">
                    <button id="btn-show" onclick="app.actionShow()" class="danger" disabled>SHOW</button>
                    <button id="btn-discard" onclick="app.actionDiscard()" disabled>DISCARD</button>
                    <button id="btn-scoreboard" onclick="app.showScoreboard()">SCORE</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 4. Scoreboard Screen -->
    <div id="scoreboard-screen" class="screen">
        <div id="scoreboard-container">
            <h2 style="text-align:center;">Scoreboard</h2>
            <p id="round-end-message" style="text-align:center; font-weight:bold;"></p>
            <table id="score-table"></table>
            <div style="margin-top:20px; text-align:center;">
                <button onclick="app.closeScoreboard()" id="close-scoreboard-btn">Close</button>
            </div>
        </div>
    </div>

    <div id="toast">Message</div>

<script type="module">
const { initializeApp, getDatabase, ref, set, onValue, get, update, onDisconnect } = window.firebaseSDK;

const firebaseConfig = {
    apiKey: "AIzaSyAZ7-gmZfu6nfRvY-4hqdqQ86lGE405RQU",
    authDomain: "pointgame-281d5.firebaseapp.com",
    databaseURL: "https://pointgame-281d5-default-rtdb.asia-southeast1.firebasedatabase.app/",
    projectId: "pointgame-281d5",
    storageBucket: "pointgame-281d5.appspot.com",
    messagingSenderId: "1006005693168",
    appId: "1:1006005693168:web:e26847ed3f4371146bf035"
};

const firebaseApp = initializeApp(firebaseConfig);
const db = getDatabase(firebaseApp);

class PointGame {
    constructor() {
        this.myId = localStorage.getItem('pointGamePlayerId') || 'player_' + Date.now() + Math.random().toString(36).substr(2, 5);
        localStorage.setItem('pointGamePlayerId', this.myId);
        this.myName = '';
        this.isHost = false;
        this.gameCode = null;
        this.gameRef = null;
        this.selectedCardIndices = [];
        this.previousHandSize = 0;
    }

    // --- LOBBY & CONNECTION ---

    showScreen(id) {
        document.querySelectorAll('.screen').forEach(s => s.classList.remove('active-screen'));
        document.getElementById(id).classList.add('active-screen');
    }

    showToast(msg) {
        const t = document.getElementById('toast');
        t.innerText = msg;
        t.style.opacity = 1;
        setTimeout(() => t.style.opacity = 0, 2500);
    }

    showJoinInput() { document.getElementById('join-container').style.display = 'block'; }
    
    copyLobbyLink() {
        const url = window.location.href.split('?')[0] + '?gameCode=' + this.gameCode;
        navigator.clipboard.writeText(url).then(() => this.showToast('Game link copied!'));
    }

    async createLobby() {
        this.myName = document.getElementById('username').value.trim();
        if (!this.myName) return this.showToast("Please enter your name.");
        
        this.isHost = true;
        this.gameCode = Math.random().toString(36).substring(2, 8).toUpperCase();
        this.gameRef = ref(db, 'games/' + this.gameCode);

        const initialGameState = {
            hostId: this.myId,
            status: 'lobby',
            settings: { latePenalty: 10 },
            players: { [this.myId]: { name: this.myName, online: true } },
            currentRound: 0,
        };

        await set(this.gameRef, initialGameState);
        this.listenForGameUpdates();
    }

    async joinLobby() {
        this.myName = document.getElementById('username').value.trim();
        const code = document.getElementById('room-code-input').value.trim().toUpperCase();
        if (!this.myName || !code) return this.showToast("Enter name and code.");

        this.gameCode = code;
        this.gameRef = ref(db, 'games/' + this.gameCode);

        const snapshot = await get(this.gameRef);
        if (!snapshot.exists()) return this.showToast("Game code not found.");

        const gameData = snapshot.val();
        const updates = {
            [`players/${this.myId}/name`]: this.myName,
            [`players/${this.myId}/online`]: true
        };
        
        if (gameData.status !== 'lobby' && gameData.currentRound > 0) {
            for (let i = 1; i <= gameData.currentRound; i++) {
                updates[`scores/${i}/${this.myId}`] = gameData.scores?.[i]?.[this.myId] === undefined ? gameData.settings.latePenalty : gameData.scores[i][this.myId];
            }
        }
        
        await update(this.gameRef, updates);
        this.listenForGameUpdates();
    }
    
    listenForGameUpdates() {
        const playerStatusRef = ref(db, `games/${this.gameCode}/players/${this.myId}/online`);
        onDisconnect(playerStatusRef).set(false);

        onValue(this.gameRef, (snapshot) => {
            if (!snapshot.exists()) {
                alert("The game has ended or the host has left.");
                location.reload();
                return;
            }
            const gameData = snapshot.val();
            
            if (gameData.players && !gameData.players[this.myId]) {
                alert("You have been removed from the game.");
                location.reload();
                return;
            }

            this.render(gameData);
        });
    }

    // --- GAME ACTIONS (WRITING TO FIREBASE) ---
    
    updateSettings() {
        if (!this.isHost) return;
        const penalty = parseInt(document.getElementById('late-penalty-input').value) || 10;
        update(this.gameRef, { 'settings/latePenalty': penalty });
    }
    
    async kickPlayer(playerId) {
        if (!this.isHost) return;
        
        const updates = { [`players/${playerId}`]: null };

        const snapshot = await get(this.gameRef);
        const gameData = snapshot.val();
        if (gameData.scores) {
            Object.keys(gameData.scores).forEach(roundNum => {
                updates[`scores/${roundNum}/${playerId}`] = null;
            });
        }
        await update(this.gameRef, updates);
    }
    
    async startGame() {
        if (!this.isHost) return;
        const snapshot = await get(ref(db, `games/${this.gameCode}/players`));
        if (Object.keys(snapshot.val() || {}).length < 2) return this.showToast("Need at least 2 players.");

        await this.startNewRound(1);
    }
    
    async startNewRound(roundNumber) {
        if (!this.isHost) return;

        const playersSnapshot = await get(ref(db, `games/${this.gameCode}/players`));
        const playerIds = Object.keys(playersSnapshot.val() || {});
        
        let deck = this._createDeck();
        deck = this._shuffle(deck);

        const updates = {
            status: 'playing',
            currentRound: roundNumber,
            turnIndex: (roundNumber - 1) % playerIds.length,
            turnPhase: 'discard',
        };

        playerIds.forEach(pid => {
            updates[`players/${pid}/hand`] = deck.splice(0, 7);
        });

        updates.tray = [deck.pop()];
        updates.drawPile = deck;

        await update(this.gameRef, updates);
    }

    async actionDiscard() {
        const gameData = (await get(this.gameRef)).val();
        const player = gameData.players[this.myId];
        const cardsToDiscard = this.selectedCardIndices.map(i => player.hand[i]);
        const newHand = player.hand.filter((_, index) => !this.selectedCardIndices.includes(index));
        
        // Animate discarding cards
        this.selectedCardIndices.forEach(index => {
            const cardEl = document.querySelector(`.card[data-index="${index}"]`);
            if (cardEl) {
                cardEl.classList.add('discarding');
            }
        });
        
        const tray = gameData.tray || [];
        const eligibleTrayCardIndex = tray.length > 0 ? tray.length - 1 : -1;

        const newTray = [...tray, ...cardsToDiscard];

        this.selectedCardIndices = [];
        
        // Wait for animation before updating
        setTimeout(async () => {
            await update(this.gameRef, {
                [`players/${this.myId}/hand`]: newHand,
                'tray': newTray,
                'turnPhase': 'pick',
                'eligibleTrayCardIndex': eligibleTrayCardIndex 
            });
        }, 300);
    }

    async pickCard(source) {
        const gameData = (await get(this.gameRef)).val();
        const playerIds = Object.keys(gameData.players);
        if (playerIds[gameData.turnIndex] !== this.myId || gameData.turnPhase !== 'pick') return;

        let pickedCard;
        let updates = {};
        let drawPile = gameData.drawPile || [];
        let tray = gameData.tray || [];

        if (source === 'draw') {
            if (drawPile.length === 0) {
                const eligibleIndex = gameData.eligibleTrayCardIndex;
                let cardsToShuffle = [];
                let keptCard = null;

                if (eligibleIndex > -1 && tray[eligibleIndex]) {
                    keptCard = tray[eligibleIndex];
                    cardsToShuffle = tray.filter((_, index) => index !== eligibleIndex);
                } else {
                    cardsToShuffle = tray;
                }
                
                if (cardsToShuffle.length === 0) return this.showToast("No cards left to draw!");

                drawPile = this._shuffle(cardsToShuffle);
                tray = keptCard ? [keptCard] : [];
            }
            pickedCard = drawPile.pop();

        } else { // 'tray'
            const eligibleIndex = gameData.eligibleTrayCardIndex;
            if (eligibleIndex === undefined || eligibleIndex < 0 || !tray[eligibleIndex]) {
                return; 
            }
            
            pickedCard = tray[eligibleIndex];
            tray.splice(eligibleIndex, 1);
        }
        
        updates.drawPile = drawPile;
        updates.tray = tray;
        updates[`players/${this.myId}/hand`] = [...(gameData.players[this.myId].hand || []), pickedCard];
        updates.turnIndex = (gameData.turnIndex + 1) % playerIds.length;
        updates.turnPhase = 'discard';
        updates.eligibleTrayCardIndex = null;

        // Animate picking card
        if (source === 'draw') {
            const drawPileEl = document.getElementById('draw-pile');
            if (drawPileEl) {
                drawPileEl.style.transform = 'scale(0.9)';
                setTimeout(() => {
                    drawPileEl.style.transform = 'scale(1)';
                }, 200);
            }
        } else {
            const discardPileEl = document.getElementById('discard-pile');
            if (discardPileEl) {
                const cardEl = discardPileEl.querySelector('.card');
                if (cardEl) {
                    cardEl.classList.add('picking');
                    setTimeout(() => cardEl.classList.remove('picking'), 500);
                }
            }
        }

        await update(this.gameRef, updates);
    }
    
    async actionShow() {
        const gameData = (await get(this.gameRef)).val();
        const me = gameData.players[this.myId];
        const mySum = this._calculateHandSum(me.hand);

        if (mySum > 5) return this.showToast("Sum must be 5 or less to show.");
        
        if (this.isHost) {
            await this._calculateAndSetScores(gameData);
        } else {
            await update(this.gameRef, { status: 'calculating_scores' });
        }
    }

    async _calculateAndSetScores(gameData) {
        const playerIds = Object.keys(gameData.players);
        const showerId = playerIds[gameData.turnIndex];
        const shower = gameData.players[showerId];
        const showerSum = this._calculateHandSum(shower.hand);

        let playerSums = {};
        playerIds.forEach(pid => {
            playerSums[pid] = this._calculateHandSum(gameData.players[pid].hand);
        });

        const winners = Object.entries(playerSums).filter(([pid, sum]) => sum <= showerSum);
        
        const updates = { status: 'round_over' };
        const roundScores = {};
        let message = "";
        
        if (winners.length === 1 && winners[0][0] === showerId) {
            message = `${shower.name} wins with the lowest score!`;
            playerIds.forEach(pid => {
                roundScores[pid] = (pid === showerId) ? 0 : playerSums[pid];
            });
        } else {
            const beatOrTiedCount = winners.filter(([pid]) => pid !== showerId).length;
            message = `${shower.name} made a wrong show!`;
            if (showerSum === 0 && winners.length > 1) {
                 message = `A 0-0 tie! Both players get 0.`;
            }
            
            playerIds.forEach(pid => {
                if (playerSums[pid] <= showerSum) {
                    roundScores[pid] = 0; // Winners get 0
                } else if (pid === showerId) {
                    roundScores[pid] = 30 * beatOrTiedCount; // Loser penalty
                } else {
                    roundScores[pid] = playerSums[pid]; // Others get their sum
                }
            });
        }
        
        updates[`scores/${gameData.currentRound}`] = roundScores;
        updates.roundEndMessage = message;
        await update(this.gameRef, updates);

        setTimeout(async () => {
             if (this.isHost) {
                await this.startNewRound(gameData.currentRound + 1);
            }
        }, 6000);
    }
    
    showScoreboard() { document.getElementById('scoreboard-screen').classList.add('active-screen'); }
    closeScoreboard() { document.getElementById('scoreboard-screen').classList.remove('active-screen'); }

    // --- CARD & DECK LOGIC (PRIVATE) ---

    _createDeck() {
        let deck = [];
        const SUITS = ['‚ô•', '‚ô¶', '‚ô£', '‚ô†'];
        for (let d = 0; d < 2; d++) {
            for (let s of SUITS) {
                for (let v = 1; v <= 13; v++) deck.push({ v, s });
            }
        }
        for (let j = 0; j < 5; j++) deck.push({ v: 0, s: 'Joker' });
        return deck;
    }

    _shuffle(deck) {
        for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }
        return deck;
    }
    
    _getCardDisplay(card) {
        if (card.s === 'Joker') return { display: 'JOKER', color: 'black' };
        const color = ['‚ô•', '‚ô¶'].includes(card.s) ? 'red' : 'black';
        let display;
        if (card.v === 1) display = 'A';
        else if (card.v === 11) display = 'J';
        else if (card.v === 12) display = 'Q';
        else if (card.v === 13) display = 'K';
        else display = card.v;
        return { display, color };
    }

    _calculateHandSum(hand) {
        if (!hand) return 0;
        return hand.reduce((sum, card) => sum + card.v, 0);
    }
    
    _toggleCardSelect(index, myHand) {
        if (this.selectedCardIndices.includes(index)) {
            this.selectedCardIndices = this.selectedCardIndices.filter(i => i !== index);
        } else {
            if (this.selectedCardIndices.length > 0) {
                const firstSelectedValue = myHand[this.selectedCardIndices[0]].v;
                if (myHand[index].v !== firstSelectedValue) {
                    // Invalid move - shake animation
                    const cards = document.querySelectorAll('.card[data-index]');
                    cards.forEach(card => {
                        if (this.selectedCardIndices.includes(parseInt(card.dataset.index))) {
                            card.classList.add('shake');
                            setTimeout(() => card.classList.remove('shake'), 500);
                        }
                    });
                    const clickedCard = document.querySelector(`.card[data-index="${index}"]`);
                    if (clickedCard) {
                        clickedCard.classList.add('shake');
                        setTimeout(() => clickedCard.classList.remove('shake'), 500);
                    }
                    this.selectedCardIndices = [index];
                } else {
                    this.selectedCardIndices.push(index);
                }
            } else {
                this.selectedCardIndices.push(index);
            }
        }
    }
    
    // Position opponents in an arc
    _positionOpponentsInArc(oppContainer, opponentElements, totalOpponents) {
        if (opponentElements.length === 0) return;
        
        const centerX = oppContainer.offsetWidth / 2;
        const radius = Math.min(oppContainer.offsetWidth * 0.4, 300);
        const arcAngle = Math.min(opponentElements.length * 20, 120); // Max 120 degrees
        const startAngle = (180 - arcAngle) / 2;
        
        opponentElements.forEach((el, index) => {
            const angle = startAngle + (arcAngle / (opponentElements.length - 1 || 1)) * index;
            const radian = (angle * Math.PI) / 180;
            const x = centerX + radius * Math.cos(radian) - el.offsetWidth / 2;
            const y = 10 + Math.sin(radian) * 30; // Slight vertical curve
            
            el.style.left = `${x}px`;
            el.style.top = `${y}px`;
        });
    }
    
    // Fan out player hand
    _fanOutHand(cards) {
        const totalCards = cards.length;
        if (totalCards === 0) return;
        
        const maxRotation = 15; // degrees
        const maxOffset = 20; // pixels
        const centerIndex = Math.floor(totalCards / 2);
        
        cards.forEach((card, index) => {
            const offset = index - centerIndex;
            const rotation = (offset / totalCards) * maxRotation;
            const yOffset = Math.abs(offset) * 2;
            
            card.style.transform = `rotate(${rotation}deg) translateY(${-yOffset}px)`;
            card.style.zIndex = totalCards - Math.abs(offset);
        });
    }

    // --- UI RENDERING ---

    render(gameData) {
        const { status, players, hostId, turnIndex, turnPhase, settings } = gameData;

        if (status === 'lobby') {
            this.showScreen('lobby-screen');
            document.getElementById('lobby-code-display').innerText = this.gameCode;
            document.getElementById('host-settings').style.display = this.isHost ? 'block' : 'none';
            document.getElementById('start-game-btn').style.display = this.isHost ? 'block' : 'none';
            document.getElementById('waiting-text').style.display = this.isHost ? 'none' : 'block';
            if(this.isHost) document.getElementById('late-penalty-input').value = settings.latePenalty;

            const list = document.getElementById('lobby-list');
            list.innerHTML = '';
            Object.entries(players || {}).forEach(([pid, p]) => {
                let li = document.createElement('li');
                li.innerHTML = `<span>${p.name} ${pid === hostId ? 'üëë' : ''}</span><span style="color:${p.online ? 'lightgreen' : 'gray'}">${p.online ? 'Online' : 'Offline'}</span>`;
                if (this.isHost && pid !== this.myId) {
                    let kickBtn = document.createElement('button');
                    kickBtn.innerText = 'Kick';
                    kickBtn.className = 'danger';
                    kickBtn.style.cssText = 'font-size:10px; padding: 4px 8px; margin:0;';
                    kickBtn.onclick = () => this.kickPlayer(pid);
                    li.appendChild(kickBtn);
                }
                list.appendChild(li);
            });

        } else if (status === 'playing' || status === 'round_over' || status === 'calculating_scores') {
            this.showScreen('game-screen');
            
            if (this.isHost && status === 'calculating_scores') {
                this._calculateAndSetScores(gameData);
                return; 
            }
            
            const playerIds = Object.keys(players);
            const me = players[this.myId];
            if (!me) return;
            
            const myHand = me.hand || [];
            const currentPlayerId = playerIds[turnIndex];
            const currentPlayer = players[currentPlayerId];
            const isMyTurn = currentPlayerId === this.myId;

            // Top bar
            document.getElementById('game-room-id').innerText = this.gameCode;
            document.getElementById('round-indicator').innerText = `Round: ${gameData.currentRound}`;
            document.getElementById('turn-indicator').innerText = isMyTurn ? `YOUR TURN (${turnPhase.toUpperCase()})` : `${currentPlayer.name}'s Turn`;

            // Opponents - Arc Layout
            const oppContainer = document.getElementById('opponents');
            oppContainer.innerHTML = '';
            const opponentElements = [];
            playerIds.forEach(pid => {
                if (pid !== this.myId) {
                    const p = players[pid];
                    let div = document.createElement('div');
                    div.className = `opponent ${pid === currentPlayerId ? 'active-turn' : ''}`;
                    div.innerHTML = `<div>${p.name}</div><div class="card-icon">üÇ† ${(p.hand || []).length}</div>`;
                    oppContainer.appendChild(div);
                    opponentElements.push(div);
                }
            });
            // Position opponents in arc after a brief delay to ensure layout
            setTimeout(() => {
                this._positionOpponentsInArc(oppContainer, opponentElements, opponentElements.length);
            }, 10);

            // Decks
            const drawPileEl = document.getElementById('draw-pile');
            const discardPileEl = document.getElementById('discard-pile');
            document.getElementById('draw-count').innerText = (gameData.drawPile || []).length;
            
            const tray = gameData.tray || [];
            const isMyPickPhase = isMyTurn && turnPhase === 'pick';

            const eligibleIndex = gameData.eligibleTrayCardIndex;
            const isEligibleCardVisible = isMyPickPhase && eligibleIndex > -1 && tray[eligibleIndex];
            const topCardToDisplay = isEligibleCardVisible
                ? tray[eligibleIndex] 
                : tray[tray.length - 1];

            // Visually separate pickable tray card
            discardPileEl.classList.remove('pickable');
            if (isEligibleCardVisible) {
                discardPileEl.classList.add('pickable');
            }

            if (topCardToDisplay) {
                const { display, color } = this._getCardDisplay(topCardToDisplay);
                const isJoker = topCardToDisplay.s === 'Joker';
                const cardStyle = isEligibleCardVisible 
                    ? 'position:absolute; transform: translateY(-10px) scale(1.1); z-index: 5;'
                    : 'position:absolute;';
                discardPileEl.innerHTML = `<div class="card ${color} ${isJoker ? 'joker' : ''}" style="${cardStyle}">
                    <div class="card-corner">${display}<br>${isJoker ? '' : topCardToDisplay.s}</div><div class="card-center">${isJoker ? 'JOKER' : topCardToDisplay.s}</div><div class="card-corner bottom">${display}<br>${isJoker ? '' : topCardToDisplay.s}</div>
                </div>`;
            } else {
                discardPileEl.innerHTML = `<span>TRAY<br>(Empty)</span>`;
            }
            
            // My Hand - Fanned Layout
            const handContainer = document.getElementById('hand-container');
            const previousHandSize = this.previousHandSize || 0;
            const isNewRound = myHand.length === 7 && previousHandSize === 0;
            this.previousHandSize = myHand.length;
            
            handContainer.innerHTML = '';
            const cardElements = [];
            myHand.slice().sort((a,b) => a.v - b.v).forEach((card, sortedIndex) => {
                const realIndex = myHand.findIndex(c => c === card);
                const { display, color } = this._getCardDisplay(card);
                const isJoker = card.s === 'Joker';
                let cDiv = document.createElement('div');
                cDiv.className = `card ${color} ${isJoker ? 'joker' : ''}`;
                cDiv.dataset.index = realIndex;
                cDiv.innerHTML = `<div class="card-corner">${display}<br>${isJoker ? '' : card.s}</div><div class="card-center">${isJoker ? 'JOKER' : card.s}</div><div class="card-corner bottom">${display}<br>${isJoker ? '' : card.s}</div>`;
                
                // Add animation for new cards or dealing
                if (isNewRound) {
                    cDiv.style.opacity = '0';
                    cDiv.style.transform = 'scale(0.3) rotate(180deg)';
                    setTimeout(() => {
                        cDiv.style.opacity = '1';
                        cDiv.classList.add('dealing');
                        setTimeout(() => {
                            cDiv.classList.remove('dealing');
                            cDiv.style.transform = ''; // Clear so fan-out can apply
                        }, 600);
                    }, sortedIndex * 80 + 50);
                } else if (myHand.length > previousHandSize && sortedIndex === myHand.length - 1) {
                    cDiv.classList.add('picking');
                    setTimeout(() => cDiv.classList.remove('picking'), 500);
                }
                
                cDiv.onclick = () => {
                    if (isMyTurn && turnPhase === 'discard') {
                        this._toggleCardSelect(realIndex, myHand);
                        this.render(gameData);
                    }
                };
                if (this.selectedCardIndices.includes(realIndex)) cDiv.classList.add('selected');
                handContainer.appendChild(cDiv);
                cardElements.push(cDiv);
            });
            
            // Fan out the hand (after dealing animation completes)
            setTimeout(() => {
                this._fanOutHand(cardElements);
            }, isNewRound ? myHand.length * 80 + 700 : 50);

            // Controls
            const btnDiscard = document.getElementById('btn-discard');
            const btnShow = document.getElementById('btn-show');
            const currentSum = this._calculateHandSum(myHand);
            // Update prominent hand sum display (poker chip style)
            const sumDisplay = document.getElementById('hand-sum-display');
            if (sumDisplay) {
                sumDisplay.innerHTML = `<span style="font-size: 20px; font-weight: 900;">${currentSum}</span>`;
            } else {
                // Initialize if not found
                const playerArea = document.getElementById('player-area');
                if (playerArea) {
                    const newSumDisplay = document.createElement('div');
                    newSumDisplay.id = 'hand-sum-display';
                    newSumDisplay.innerHTML = `<span style="font-size: 20px; font-weight: 900;">${currentSum}</span>`;
                    const handContainer = document.getElementById('hand-container');
                    if (handContainer && handContainer.parentNode) {
                        handContainer.parentNode.insertBefore(newSumDisplay, handContainer);
                    }
                }
            }
            
            btnDiscard.disabled = true;
            btnShow.disabled = true;
            drawPileEl.classList.remove('actionable');
            discardPileEl.classList.remove('actionable');

            if (isMyTurn) {
                if (turnPhase === 'discard') {
                    btnShow.disabled = currentSum > 5;
                    if (this.selectedCardIndices.length > 0) {
                        const selectedCards = this.selectedCardIndices.map(i => myHand[i]);
                        const allSame = selectedCards.every(c => c.v === selectedCards[0].v);
                        btnDiscard.disabled = !allSame || selectedCards.length === 0;
                    }
                } else { // pick phase
                    drawPileEl.classList.add('actionable');
                    if (eligibleIndex > -1 && tray[eligibleIndex]) {
                         discardPileEl.classList.add('actionable');
                    }
                }
            }
            
            if (status === 'round_over') {
                this.renderScoreboard(gameData);
                document.getElementById('scoreboard-screen').classList.add('active-screen');
                document.getElementById('round-end-message').innerText = gameData.roundEndMessage || "Round Over!";
            }
        }
    }
    
    renderScoreboard(gameData) {
        const table = document.getElementById('score-table');
        table.innerHTML = '';
        const players = gameData.players || {};
        const playerIds = Object.keys(players);
        if (playerIds.length === 0) return;

        // Header
        const thead = document.createElement('thead');
        let headerRow = '<tr><th>Round</th>';
        playerIds.forEach(pid => { if(players[pid]) headerRow += `<th>${players[pid].name}</th>` });
        headerRow += '</tr>';
        thead.innerHTML = headerRow;
        table.appendChild(thead);

        // Body
        const tbody = document.createElement('tbody');
        const totals = playerIds.reduce((acc, pid) => ({ ...acc, [pid]: 0 }), {});
        for (let r = 1; r <= gameData.currentRound; r++) {
            let row = `<tr><td>${r}</td>`;
            playerIds.forEach(pid => {
                if(players[pid]) {
                    const score = gameData.scores?.[r]?.[pid] ?? 0;
                    row += `<td>${score}</td>`;
                    totals[pid] += score;
                }
            });
            row += '</tr>';
            tbody.innerHTML += row;
        }
        table.appendChild(tbody);

        // Footer
        const tfoot = document.createElement('tfoot');
        let footerRow = '<tr><td>TOTAL</td>';
        playerIds.forEach(pid => { if(players[pid]) footerRow += `<td>${totals[pid]}</td>` });
        footerRow += '</tr>';
        tfoot.innerHTML = footerRow;
        table.appendChild(tfoot);
    }
}

window.app = new PointGame();

window.addEventListener('load', () => {
    const params = new URLSearchParams(window.location.search);
    const gameCode = params.get('gameCode');
    if (gameCode) {
        document.getElementById('room-code-input').value = gameCode;
        app.showJoinInput();
        app.showToast("Enter your name to join!");
    }
});
</script>
</body>
</html>