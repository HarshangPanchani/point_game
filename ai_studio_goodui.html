<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>POINT - The Greatest Card Game</title>
    <!-- Firebase SDK -->
    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
      import { getDatabase, ref, set, onValue, get, update, onDisconnect } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";
      window.firebaseSDK = { initializeApp, getDatabase, ref, set, onValue, get, update, onDisconnect };
    </script>
    <style>
        :root {
            --bg-color: #013220;
            --table-color-center: #025a30;
            --table-color-outer: #014222;
            --card-width: 70px;
            --card-height: 98px;
            --text-light: #f5f5f5;
            --accent: #FFD700; /* Gold */
            --danger: #d90429;
            --primary: #2a9d8f;
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* --- BASE SETUP --- */
        * { box-sizing: border-box; user-select: none; -webkit-user-select: none; -webkit-tap-highlight-color: transparent; }
        body {
            margin: 0; padding: 0;
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-light);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }
        #portrait-warning {
            display: none; flex-direction: column; justify-content: center; align-items: center; text-align: center;
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #1a1a1a; z-index: 9999; padding: 20px;
        }
        @media (orientation: portrait) { #portrait-warning { display: flex; } }

        /* --- SCREENS & MODALS --- */
        .screen {
            display: none; flex-direction: column; align-items: center; justify-content: center;
            width: 100%; height: 100%; position: absolute; top: 0; left: 0;
            padding: 10px; overflow: auto; transition: opacity 0.3s, backdrop-filter 0.3s;
        }
        .active-screen { display: flex; }
        #scoreboard-screen { background: rgba(0,0,0,0.7); backdrop-filter: blur(5px); }
        
        /* --- UI ELEMENTS (BUTTONS, INPUTS) --- */
        input, button {
            padding: 12px 18px; margin: 8px; border-radius: 8px; border: none; font-size: 16px; font-weight: bold;
        }
        button { 
            cursor: pointer; background: var(--primary); color: #fff; 
            transition: all 0.2s ease; box-shadow: 0 4px 6px rgba(0,0,0,0.2), inset 0 -2px 1px rgba(0,0,0,0.3);
        }
        button:hover { filter: brightness(1.1); }
        button:active { transform: scale(0.97); box-shadow: 0 2px 3px rgba(0,0,0,0.2), inset 0 -1px 1px rgba(0,0,0,0.3); }
        button:disabled { background: #999; cursor: not-allowed; color: #ccc; box-shadow: none; filter: none; }
        button.danger { background: var(--danger); }
        button.accent { background: var(--accent); color: #000; }
        input { color: #000; text-align: center; width: 100%; }

        /* --- LOBBY STYLES --- */
        .lobby-box { background: rgba(0,0,0,0.3); padding: 20px; border-radius: 12px; width: clamp(300px, 90vw, 500px); }
        #lobby-list {
            list-style: none; padding: 0; width: 100%;
            background: rgba(0,0,0,0.3); border-radius: 10px; margin-top: 15px;
        }
        #lobby-list li {
            padding: 12px; border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex; justify-content: space-between; align-items: center;
        }
        #lobby-code-display { font-family: monospace; background: #fff; color: #000; padding: 5px 10px; border-radius: 5px; cursor: pointer; user-select: text; }

        /* --- MAIN GAME SCREEN LAYOUT --- */
        #game-screen { background: radial-gradient(ellipse at center, var(--table-color-center), var(--table-color-outer)); }
        #game-ui { width: 100%; height: 100%; position: relative; overflow: hidden; }

        /* --- TOP BAR & OPPONENTS --- */
        #top-bar {
            position: absolute; top: 0; left: 0; width: 100%;
            background: linear-gradient(rgba(0,0,0,0.7), transparent);
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 20px; font-size: 14px; z-index: 10; pointer-events: none;
        }
        #turn-indicator { font-weight: bold; color: var(--accent); font-size: 16px; }
        
        #opponents-container {
            position: absolute; top: 50%; left: 50%; width: 1px; height: 1px;
        }
        .opponent {
            position: absolute; transform-origin: center;
            background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 10px;
            text-align: center; font-size: 12px; border: 2px solid transparent;
            width: 90px; transition: border-color 0.3s, transform 0.5s ease-out;
            will-change: transform;
        }
        .opponent.active-turn { border: 2px solid var(--accent); }
        .opponent .card-icon { font-size: 18px; }

        /* --- CENTER TABLE (PILES) --- */
        #table-area {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            display: flex; justify-content: center; align-items: center; gap: 30px;
        }
        .deck-placeholder {
            width: calc(var(--card-width) + 10px); height: calc(var(--card-height) + 10px);
            border: 2px dashed rgba(255,255,255,0.3); border-radius: 8px;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            position: relative; background: rgba(0,0,0,0.2);
            cursor: pointer; transition: border-color 0.2s, transform 0.2s;
        }
        .deck-placeholder.actionable { border-style: solid; border-color: var(--accent); }
        .deck-placeholder.actionable:hover { transform: scale(1.05); }
        .deck-placeholder span { font-size: 12px; text-align: center; color: rgba(255,255,255,0.8); }

        #eligible-tray-card-spot {
            border-color: transparent; background: transparent;
        }
        #eligible-tray-card-spot.actionable { border-style: solid; border-color: var(--accent); }

        /* --- PLAYER HAND AREA --- */
        #player-area {
            position: absolute; bottom: 0; left: 0; width: 100%;
            display: flex; flex-direction: column; align-items: center;
            background: linear-gradient(transparent, rgba(0,0,0,0.8));
            padding-bottom: 5px;
        }
        #hand-container {
            display: flex; justify-content: center; align-items: flex-end;
            height: 130px; width: 100%; padding: 0 10px 25px 10px;
        }
        #controls { display: flex; gap: 10px; margin-top: -15px; align-items: center; position: relative; }
        #hand-sum-badge {
            position: absolute; left: -60px; top: 50%; transform: translateY(-50%);
            width: 50px; height: 50px; border-radius: 50%;
            background: radial-gradient(circle, #4a4a4a, #1a1a1a);
            border: 2px solid var(--accent);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            font-weight: bold; line-height: 1; box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
        #hand-sum-badge span:first-child { font-size: 10px; color: #ccc; }
        #hand-sum-badge span:last-child { font-size: 20px; color: var(--text-light); }

        /* --- CARD VISUALS & ANIMATIONS --- */
        .card {
            width: var(--card-width); height: var(--card-height);
            background: #fff; color: #000; border-radius: 6px;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 4px 5px; box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            font-weight: bold; font-family: 'Times New Roman', Times, serif;
            cursor: pointer; position: relative;
            transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1), border 0.2s;
            border: 2px solid #333;
            transform-origin: bottom center;
        }
        #hand-container .card { margin: 0 -25px; }
        #hand-container .card:hover { transform: translateY(-20px) scale(1.05); }
        .card.selected { transform: translateY(-30px) scale(1.05); border: 2px solid var(--accent); }
        .card.red { color: var(--danger); }
        .card.black { color: black; }
        .card-center { font-size: 32px; align-self: center; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); opacity: 0.8; }
        .card-corner { font-size: 16px; line-height: 1; }
        .card-corner.bottom { transform: rotate(180deg); align-self: flex-end; }
        .card.joker .card-center { font-size: 16px; font-weight: bold; letter-spacing: -1px; text-align: center; line-height: 1.1; }
        
        .card-back {
            background: linear-gradient(135deg, #4682b4, #5a9bd5); border: 5px solid white;
        }
        .card-back::after { content: "üÉè"; font-size: 40px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }

        @keyframes shake { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-4px, 0, 0); } 40%, 60% { transform: translate3d(4px, 0, 0); } }
        .shake { animation: shake 0.82s cubic-bezier(.36,.07,.19,.97) both; }

        #animation-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 100; pointer-events: none; }

        /* --- SCOREBOARD --- */
        #scoreboard-container { background: var(--bg-color); border: 2px solid var(--accent); border-radius: 12px; padding: 20px; width: 95vw; max-width: 800px; max-height: 90vh; overflow: auto; }
        table { width: 100%; border-collapse: collapse; background: white; color: black; font-size: 14px; }
        th, td { border: 1px solid #ccc; padding: 8px; text-align: center; }
        th { background: #eee; }
        tfoot { font-weight: bold; font-size: 16px; }
        tfoot td { background: var(--accent); color: #000; }
        
        /* --- TOAST NOTIFICATION --- */
        #toast {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.9); color: white; padding: 12px 24px;
            border-radius: 25px; opacity: 0; pointer-events: none; transition: all 0.3s;
            z-index: 10000; font-size: 14px;
        }
        #toast.show { opacity: 1; bottom: 30px; }
    </style>
</head>
<body>
    <div id="portrait-warning"><h1>Please Rotate Your Device</h1><p>This game is best played in Landscape mode.</p></div>
    <div id="animation-layer"></div>

    <!-- SCREENS -->
    <div id="start-screen" class="screen active-screen">
        <div class="lobby-box">
            <h1>POINT</h1>
            <input type="text" id="username" placeholder="Enter Your Name" maxlength="12">
            <div><button onclick="app.createLobby()" class="accent">Create Lobby</button><button onclick="app.showJoinInput()">Join Lobby</button></div>
            <div id="join-container" style="display:none; margin-top:10px;">
                <input type="text" id="room-code-input" placeholder="Enter Lobby Code" style="text-transform:uppercase;">
                <button onclick="app.joinLobby()">Connect</button>
            </div>
        </div>
    </div>

    <div id="lobby-screen" class="screen">
        <div class="lobby-box">
            <h2>Lobby Code: <span id="lobby-code-display" onclick="app.copyLobbyLink()">CODE</span></h2>
            <div id="host-settings" style="display:none; margin-bottom: 10px; text-align:center;">
                <label>Late Joiner Penalty Score: </label>
                <input type="number" id="late-penalty-input" value="10" style="width:80px; padding:8px;" onchange="app.updateSettings()">
            </div>
            <p>Players:</p><ul id="lobby-list"></ul>
            <div id="lobby-controls" style="text-align:center;"><button id="start-game-btn" style="display:none" onclick="app.startGame()" class="accent">Start Game</button></div>
            <p id="waiting-text" style="text-align:center; font-style:italic;">Waiting for host to start...</p>
        </div>
    </div>

    <div id="game-screen" class="screen">
        <div id="game-ui">
            <div id="top-bar"><span>Room: <span id="game-room-id"></span></span><span id="round-indicator">Round: 1</span><span id="turn-indicator">Waiting...</span></div>
            <div id="opponents-container"></div>
            <div id="table-area">
                <div class="deck-placeholder" id="draw-pile" onclick="app.pickCard('draw')"><span>DRAW (<span id="draw-count">0</span>)</span></div>
                <div class="deck-placeholder" id="discard-pile"><span>TRAY</span></div>
                <div class="deck-placeholder" id="eligible-tray-card-spot" onclick="app.pickCard('tray')"></div>
            </div>
            <div id="player-area">
                <div id="hand-container"></div>
                <div id="controls">
                    <div id="hand-sum-badge"><span>SUM</span><span>0</span></div>
                    <button id="btn-show" onclick="app.actionShow()" class="danger" disabled>SHOW</button>
                    <button id="btn-discard" onclick="app.actionDiscard()" disabled>DISCARD</button>
                    <button id="btn-scoreboard" onclick="app.showScoreboard()">SCORE</button>
                </div>
            </div>
        </div>
    </div>

    <div id="scoreboard-screen" class="screen">
        <div id="scoreboard-container">
            <h2 style="text-align:center;">Scoreboard</h2>
            <p id="round-end-message" style="text-align:center; font-weight:bold;"></p>
            <table id="score-table"></table>
            <div style="margin-top:20px; text-align:center;"><button onclick="app.closeScoreboard()" id="close-scoreboard-btn">Close</button></div>
        </div>
    </div>
    
    <div id="toast"></div>

<script type="module">
const { initializeApp, getDatabase, ref, set, onValue, get, update, onDisconnect } = window.firebaseSDK;

const firebaseConfig = {
    apiKey: "AIzaSyAZ7-gmZfu6nfRvY-4hqdqQ86lGE405RQU",
    authDomain: "pointgame-281d5.firebaseapp.com",
    databaseURL: "https://pointgame-281d5-default-rtdb.asia-southeast1.firebasedatabase.app/",
    projectId: "pointgame-281d5",
    storageBucket: "pointgame-281d5.appspot.com",
    messagingSenderId: "1006005693168",
    appId: "1:1006005693168:web:e26847ed3f4371146bf035"
};

const firebaseApp = initializeApp(firebaseConfig);
const db = getDatabase(firebaseApp);

class PointGame {
    constructor() {
        this.myId = localStorage.getItem('pointGamePlayerId') || 'player_' + Date.now() + Math.random().toString(36).substr(2, 5);
        localStorage.setItem('pointGamePlayerId', this.myId);
        this.myName = '';
        this.isHost = false;
        this.gameCode = null;
        this.gameRef = null;
        this.selectedCardIndices = [];
        this.lastGameState = {}; // For detecting changes to animate
    }

    // --- LOBBY & CONNECTION ---

    showScreen(id) {
        document.querySelectorAll('.screen').forEach(s => s.classList.remove('active-screen'));
        document.getElementById(id).classList.add('active-screen');
    }

    showToast(msg) {
        const t = document.getElementById('toast');
        t.innerText = msg;
        t.classList.add('show');
        setTimeout(() => t.classList.remove('show'), 2500);
    }

    showJoinInput() { document.getElementById('join-container').style.display = 'block'; }
    
    copyLobbyLink() {
        const url = window.location.href.split('?')[0] + '?gameCode=' + this.gameCode;
        navigator.clipboard.writeText(url).then(() => this.showToast('Game link copied!'));
    }

    async createLobby() {
        this.myName = document.getElementById('username').value.trim();
        if (!this.myName) return this.showToast("Please enter your name.");
        
        this.isHost = true;
        this.gameCode = Math.random().toString(36).substring(2, 8).toUpperCase();
        this.gameRef = ref(db, 'games/' + this.gameCode);

        const initialGameState = {
            hostId: this.myId,
            status: 'lobby',
            settings: { latePenalty: 10 },
            players: { [this.myId]: { name: this.myName, online: true } },
            currentRound: 0,
        };

        await set(this.gameRef, initialGameState);
        this.listenForGameUpdates();
    }

    async joinLobby() {
        this.myName = document.getElementById('username').value.trim();
        const code = document.getElementById('room-code-input').value.trim().toUpperCase();
        if (!this.myName || !code) return this.showToast("Enter name and code.");

        this.gameCode = code;
        this.gameRef = ref(db, 'games/' + this.gameCode);

        const snapshot = await get(this.gameRef);
        if (!snapshot.exists()) return this.showToast("Game code not found.");

        const gameData = snapshot.val();
        const updates = {
            [`players/${this.myId}/name`]: this.myName,
            [`players/${this.myId}/online`]: true
        };
        
        if (gameData.status !== 'lobby' && gameData.currentRound > 0) {
            for (let i = 1; i <= gameData.currentRound; i++) {
                updates[`scores/${i}/${this.myId}`] = gameData.scores?.[i]?.[this.myId] === undefined ? gameData.settings.latePenalty : gameData.scores[i][this.myId];
            }
        }
        
        await update(this.gameRef, updates);
        this.listenForGameUpdates();
    }
    
    listenForGameUpdates() {
        const playerStatusRef = ref(db, `games/${this.gameCode}/players/${this.myId}/online`);
        onDisconnect(playerStatusRef).set(false);

        onValue(this.gameRef, (snapshot) => {
            if (!snapshot.exists()) {
                alert("The game has ended or the host has left.");
                location.reload();
                return;
            }
            const gameData = snapshot.val();
            
            if (gameData.players && !gameData.players[this.myId]) {
                alert("You have been removed from the game.");
                location.reload();
                return;
            }

            this.render(gameData);
        });
    }

    // --- GAME ACTIONS (LOGIC - UNTOUCHED) ---
    
    updateSettings() {
        if (!this.isHost) return;
        const penalty = parseInt(document.getElementById('late-penalty-input').value) || 10;
        update(this.gameRef, { 'settings/latePenalty': penalty });
    }
    
    async kickPlayer(playerId) {
        if (!this.isHost) return;
        const updates = { [`players/${playerId}`]: null };
        const snapshot = await get(this.gameRef);
        const gameData = snapshot.val();
        if (gameData.scores) {
            Object.keys(gameData.scores).forEach(roundNum => {
                updates[`scores/${roundNum}/${playerId}`] = null;
            });
        }
        await update(this.gameRef, updates);
    }
    
    async startGame() {
        if (!this.isHost) return;
        const snapshot = await get(ref(db, `games/${this.gameCode}/players`));
        if (Object.keys(snapshot.val() || {}).length < 2) return this.showToast("Need at least 2 players.");
        await this.startNewRound(1);
    }
    
    async startNewRound(roundNumber) {
        if (!this.isHost) return;
        const playersSnapshot = await get(ref(db, `games/${this.gameCode}/players`));
        const playerIds = Object.keys(playersSnapshot.val() || {});
        let deck = this._createDeck();
        deck = this._shuffle(deck);
        const updates = {
            status: 'playing',
            currentRound: roundNumber,
            turnIndex: (roundNumber - 1) % playerIds.length,
            turnPhase: 'discard',
            tray: [deck.pop()],
            drawPile: deck
        };
        playerIds.forEach(pid => { updates[`players/${pid}/hand`] = deck.splice(0, 7); });
        await update(this.gameRef, updates);
    }

    async actionDiscard() {
        const gameData = (await get(this.gameRef)).val();
        const player = gameData.players[this.myId];
        const cardsToDiscard = this.selectedCardIndices.map(i => player.hand[i]);
        const newHand = player.hand.filter((_, index) => !this.selectedCardIndices.includes(index));
        const tray = gameData.tray || [];
        const eligibleTrayCardIndex = tray.length > 0 ? tray.length - 1 : -1;
        const newTray = [...tray, ...cardsToDiscard];
        this.selectedCardIndices = [];
        await update(this.gameRef, {
            [`players/${this.myId}/hand`]: newHand,
            'tray': newTray,
            'turnPhase': 'pick',
            'eligibleTrayCardIndex': eligibleTrayCardIndex 
        });
    }

    async pickCard(source) {
        const gameData = (await get(this.gameRef)).val();
        const playerIds = Object.keys(gameData.players);
        if (playerIds[gameData.turnIndex] !== this.myId || gameData.turnPhase !== 'pick') return;
        let pickedCard;
        let updates = {};
        let drawPile = gameData.drawPile || [];
        let tray = gameData.tray || [];
        if (source === 'draw') {
            if (drawPile.length === 0) {
                const eligibleIndex = gameData.eligibleTrayCardIndex;
                let cardsToShuffle = [];
                let keptCard = null;
                if (eligibleIndex > -1 && tray[eligibleIndex]) {
                    keptCard = tray[eligibleIndex];
                    cardsToShuffle = tray.filter((_, index) => index !== eligibleIndex);
                } else {
                    cardsToShuffle = tray;
                }
                if (cardsToShuffle.length === 0) return this.showToast("No cards left to draw!");
                drawPile = this._shuffle(cardsToShuffle);
                tray = keptCard ? [keptCard] : [];
            }
            pickedCard = drawPile.pop();
        } else { // 'tray'
            const eligibleIndex = gameData.eligibleTrayCardIndex;
            if (eligibleIndex === undefined || eligibleIndex < 0 || !tray[eligibleIndex]) { return; }
            pickedCard = tray[eligibleIndex];
            tray.splice(eligibleIndex, 1);
        }
        updates.drawPile = drawPile;
        updates.tray = tray;
        updates[`players/${this.myId}/hand`] = [...(gameData.players[this.myId].hand || []), pickedCard];
        updates.turnIndex = (gameData.turnIndex + 1) % playerIds.length;
        updates.turnPhase = 'discard';
        updates.eligibleTrayCardIndex = null;
        await update(this.gameRef, updates);
    }
    
    async actionShow() {
        const gameData = (await get(this.gameRef)).val();
        const mySum = this._calculateHandSum(gameData.players[this.myId].hand);
        if (mySum > 5) return this.showToast("Sum must be 5 or less to show.");
        if (this.isHost) { await this._calculateAndSetScores(gameData); } 
        else { await update(this.gameRef, { status: 'calculating_scores' }); }
    }

    async _calculateAndSetScores(gameData) {
        const playerIds = Object.keys(gameData.players);
        const showerId = playerIds[gameData.turnIndex];
        const shower = gameData.players[showerId];
        const showerSum = this._calculateHandSum(shower.hand);
        let playerSums = {};
        playerIds.forEach(pid => { playerSums[pid] = this._calculateHandSum(gameData.players[pid].hand); });
        const winners = Object.entries(playerSums).filter(([pid, sum]) => sum <= showerSum);
        const updates = { status: 'round_over' };
        const roundScores = {};
        let message = "";
        if (winners.length === 1 && winners[0][0] === showerId) {
            message = `${shower.name} wins with the lowest score!`;
            playerIds.forEach(pid => { roundScores[pid] = (pid === showerId) ? 0 : playerSums[pid]; });
        } else {
            const beatOrTiedCount = winners.filter(([pid]) => pid !== showerId).length;
            message = `${shower.name} made a wrong show!`;
            if (showerSum === 0 && winners.length > 1) { message = `A 0-0 tie! Multiple players get 0.`; }
            playerIds.forEach(pid => {
                if (playerSums[pid] <= showerSum) { roundScores[pid] = 0; }
                else if (pid === showerId) { roundScores[pid] = 30 * beatOrTiedCount; }
                else { roundScores[pid] = playerSums[pid]; }
            });
        }
        updates[`scores/${gameData.currentRound}`] = roundScores;
        updates.roundEndMessage = message;
        await update(this.gameRef, updates);
        setTimeout(async () => { if (this.isHost) { await this.startNewRound(gameData.currentRound + 1); }}, 6000);
    }
    
    showScoreboard() { document.getElementById('scoreboard-screen').classList.add('active-screen'); }
    closeScoreboard() { document.getElementById('scoreboard-screen').classList.remove('active-screen'); }

    // --- CARD & DECK HELPERS ---
    _createDeck() {
        let deck = []; const SUITS = ['‚ô•', '‚ô¶', '‚ô£', '‚ô†'];
        for (let d = 0; d < 2; d++) { for (let s of SUITS) { for (let v = 1; v <= 13; v++) deck.push({ v, s }); } }
        for (let j = 0; j < 5; j++) deck.push({ v: 0, s: 'Joker' });
        return deck;
    }
    _shuffle(deck) {
        for (let i = deck.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [deck[i], deck[j]] = [deck[j], deck[i]]; }
        return deck;
    }
    _getCardDisplay(card) {
        if (card.s === 'Joker') return { display: 'JOKER', color: 'black' };
        const color = ['‚ô•', '‚ô¶'].includes(card.s) ? 'red' : 'black';
        let display;
        if (card.v === 1) display = 'A'; else if (card.v === 11) display = 'J'; else if (card.v === 12) display = 'Q'; else if (card.v === 13) display = 'K'; else display = card.v;
        return { display, color };
    }
    _calculateHandSum(hand) { return (hand || []).reduce((sum, card) => sum + card.v, 0); }
    _toggleCardSelect(index, myHand) {
        const handEl = document.getElementById('hand-container');
        if (this.selectedCardIndices.includes(index)) {
            this.selectedCardIndices = this.selectedCardIndices.filter(i => i !== index);
        } else {
            if (this.selectedCardIndices.length > 0) {
                const firstSelectedValue = myHand[this.selectedCardIndices[0]].v;
                if (myHand[index].v !== firstSelectedValue) {
                    this.selectedCardIndices.forEach(i => handEl.querySelector(`[data-index='${i}']`)?.classList.add('shake'));
                    setTimeout(() => handEl.querySelectorAll('.shake').forEach(el => el.classList.remove('shake')), 820);
                    this.selectedCardIndices = [index];
                } else { this.selectedCardIndices.push(index); }
            } else { this.selectedCardIndices.push(index); }
        }
    }

    // --- UI RENDER & ANIMATION ---

    render(gameData) {
        const { status, players, hostId, turnIndex, turnPhase, settings } = gameData;
        
        if (status === 'lobby') {
            this.showScreen('lobby-screen');
            document.getElementById('lobby-code-display').innerText = this.gameCode;
            document.getElementById('host-settings').style.display = this.isHost ? 'block' : 'none';
            document.getElementById('start-game-btn').style.display = this.isHost ? 'block' : 'none';
            document.getElementById('waiting-text').style.display = this.isHost ? 'none' : 'block';
            if(this.isHost) document.getElementById('late-penalty-input').value = settings.latePenalty;
            const list = document.getElementById('lobby-list'); list.innerHTML = '';
            Object.entries(players || {}).forEach(([pid, p]) => {
                let li = document.createElement('li');
                li.innerHTML = `<span>${p.name} ${pid === hostId ? 'üëë' : ''}</span><span style="color:${p.online ? 'lightgreen' : 'gray'}">${p.online ? 'Online' : 'Offline'}</span>`;
                if (this.isHost && pid !== this.myId) {
                    let kickBtn = document.createElement('button'); kickBtn.innerText = 'Kick'; kickBtn.className = 'danger';
                    kickBtn.style.cssText = 'font-size:10px; padding: 4px 8px; margin:0;';
                    kickBtn.onclick = () => this.kickPlayer(pid);
                    li.appendChild(kickBtn);
                }
                list.appendChild(li);
            });
        } else if (status === 'playing' || status === 'round_over' || status === 'calculating_scores') {
            this.showScreen('game-screen');
            if (this.isHost && status === 'calculating_scores') { this._calculateAndSetScores(gameData); return; }
            
            const playerIds = Object.keys(players);
            const me = players[this.myId]; if (!me) return;
            const myHand = me.hand || [];
            const currentPlayerId = playerIds[turnIndex];
            const currentPlayer = players[currentPlayerId];
            const isMyTurn = currentPlayerId === this.myId;

            // Render top bar & turn indicator
            document.getElementById('game-room-id').innerText = this.gameCode;
            document.getElementById('round-indicator').innerText = `Round: ${gameData.currentRound}`;
            document.getElementById('turn-indicator').innerText = isMyTurn ? `YOUR TURN (${turnPhase.toUpperCase()})` : `${currentPlayer.name}'s Turn`;
            
            // Render opponents in an arc
            this.renderOpponents(players, currentPlayerId);

            // Render central piles
            this.renderPiles(gameData, isMyTurn);

            // Render my hand
            this.renderMyHand(myHand, isMyTurn, turnPhase);

            if (status === 'round_over') {
                this.renderScoreboard(gameData);
                document.getElementById('scoreboard-screen').classList.add('active-screen');
                document.getElementById('round-end-message').innerText = gameData.roundEndMessage || "Round Over!";
            }
        }
        this.lastGameState = gameData; // Store state for next render comparison
    }
    
    renderOpponents(players, currentPlayerId) {
        const oppContainer = document.getElementById('opponents-container');
        oppContainer.innerHTML = '';
        const opponentIds = Object.keys(players).filter(pid => pid !== this.myId);
        const angleStep = Math.min(30, 180 / (opponentIds.length + 1));
        const startAngle = -90 - (angleStep * (opponentIds.length - 1) / 2);
        const radiusY = window.innerHeight * 0.35;
        const radiusX = window.innerWidth * 0.4;
        
        opponentIds.forEach((pid, i) => {
            const p = players[pid];
            const angle = (startAngle + i * angleStep) * (Math.PI / 180);
            const x = radiusX * Math.cos(angle);
            const y = radiusY * Math.sin(angle);

            let div = document.createElement('div');
            div.className = `opponent ${pid === currentPlayerId ? 'active-turn' : ''}`;
            div.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
            div.innerHTML = `<div>${p.name}</div><div class="card-icon">üÇ† ${(p.hand || []).length}</div>`;
            oppContainer.appendChild(div);
        });
    }
    
    renderPiles(gameData, isMyTurn) {
        const { turnPhase, drawPile, tray, eligibleTrayCardIndex } = gameData;
        const drawPileEl = document.getElementById('draw-pile');
        const discardPileEl = document.getElementById('discard-pile');
        const eligibleSpotEl = document.getElementById('eligible-tray-card-spot');
        
        document.getElementById('draw-count').innerText = (drawPile || []).length;
        
        // Main discard pile (visual only)
        if (tray && tray.length > 0) {
            discardPileEl.innerHTML = `<div class="card-back" style="position: absolute; opacity: ${tray.length > 1 ? 1 : 0};"></div>`;
        } else {
            discardPileEl.innerHTML = '<span>TRAY</span>';
        }

        // Eligible card spot
        const isMyPickPhase = isMyTurn && turnPhase === 'pick';
        const eligibleCard = (eligibleTrayCardIndex > -1 && tray) ? tray[eligibleTrayCardIndex] : null;

        if (isMyPickPhase && eligibleCard) {
            eligibleSpotEl.innerHTML = this.getCardHTML(eligibleCard);
            eligibleSpotEl.classList.add('actionable');
        } else {
            eligibleSpotEl.innerHTML = '';
            eligibleSpotEl.classList.remove('actionable');
        }

        // Actionability
        drawPileEl.classList.toggle('actionable', isMyPickPhase);
    }
    
    renderMyHand(myHand, isMyTurn, turnPhase) {
        const handContainer = document.getElementById('hand-container');
        handContainer.innerHTML = '';
        const cardAngle = 3;
        const startAngle = - (myHand.length - 1) * cardAngle / 2;

        myHand.slice().sort((a,b) => a.v - b.v).forEach((card) => {
            const realIndex = myHand.indexOf(card);
            let cDiv = this.createCardElement(card, realIndex);
            
            const currentAngle = startAngle + myHand.indexOf(card) * cardAngle;
            cDiv.style.transform = `rotate(${currentAngle}deg) translateY(10px)`;
            cDiv.style.transitionDelay = `${myHand.indexOf(card) * 20}ms`;

            cDiv.onclick = () => {
                if (isMyTurn && turnPhase === 'discard') {
                    this._toggleCardSelect(realIndex, myHand);
                    // Re-render only hand for selection change
                    document.querySelectorAll('#hand-container .card').forEach(el => {
                        el.classList.remove('selected', 'shake');
                    });
                    this.selectedCardIndices.forEach(i => {
                        handContainer.querySelector(`[data-index='${i}']`)?.classList.add('selected');
                    });
                }
            };
            if (this.selectedCardIndices.includes(realIndex)) cDiv.classList.add('selected');
            handContainer.appendChild(cDiv);
        });

        // Controls and Sum
        const btnDiscard = document.getElementById('btn-discard');
        const btnShow = document.getElementById('btn-show');
        const currentSum = this._calculateHandSum(myHand);
        document.querySelector('#hand-sum-badge span:last-child').textContent = currentSum;
        
        btnDiscard.disabled = true;
        btnShow.disabled = true;

        if (isMyTurn && turnPhase === 'discard') {
            btnShow.disabled = currentSum > 5;
            if (this.selectedCardIndices.length > 0) {
                const selectedCards = this.selectedCardIndices.map(i => myHand[i]);
                const allSame = selectedCards.every(c => c.v === selectedCards[0].v);
                btnDiscard.disabled = !allSame;
            }
        }
    }

    createCardElement(card, index) {
        let el = document.createElement('div');
        el.className = 'card ' + this._getCardDisplay(card).color;
        if (card.s === 'Joker') el.classList.add('joker');
        el.dataset.index = index;
        el.innerHTML = this.getCardHTML(card, true);
        return el;
    }

    getCardHTML(card, isInner = false) {
        const { display, color } = this._getCardDisplay(card);
        const isJoker = card.s === 'Joker';
        const content = `<div class="card-corner">${display}<br>${isJoker ? '' : card.s}</div>
                         <div class="card-center">${isJoker ? 'JOKER' : card.s}</div>
                         <div class="card-corner bottom">${display}<br>${isJoker ? '' : card.s}</div>`;
        return isInner ? content : `<div class="card ${color} ${isJoker ? 'joker' : ''}" style="position:absolute;">${content}</div>`;
    }
    
    renderScoreboard(gameData) {
        const table = document.getElementById('score-table');
        table.innerHTML = '';
        const players = gameData.players || {};
        const playerIds = Object.keys(players).filter(pid => players[pid]);
        if (playerIds.length === 0) return;

        const thead = document.createElement('thead');
        let headerRow = '<tr><th>Round</th>';
        playerIds.forEach(pid => headerRow += `<th>${players[pid].name}</th>`);
        thead.innerHTML = headerRow + '</tr>';
        table.appendChild(thead);

        const tbody = document.createElement('tbody');
        const totals = playerIds.reduce((acc, pid) => ({ ...acc, [pid]: 0 }), {});
        for (let r = 1; r <= gameData.currentRound; r++) {
            let row = `<tr><td>${r}</td>`;
            playerIds.forEach(pid => {
                const score = gameData.scores?.[r]?.[pid] ?? 0;
                row += `<td>${score}</td>`;
                totals[pid] += score;
            });
            tbody.innerHTML += row + '</tr>';
        }
        table.appendChild(tbody);

        const tfoot = document.createElement('tfoot');
        let footerRow = '<tr><td>TOTAL</td>';
        playerIds.forEach(pid => footerRow += `<td>${totals[pid]}</td>`);
        tfoot.innerHTML = footerRow + '</tr>';
        table.appendChild(tfoot);
    }
}

window.app = new PointGame();

window.addEventListener('load', () => {
    const params = new URLSearchParams(window.location.search);
    const gameCode = params.get('gameCode');
    if (gameCode) {
        document.getElementById('room-code-input').value = gameCode;
        app.showJoinInput();
        app.showToast("Enter your name to join!");
    }
});
</script>
</body>
</html>